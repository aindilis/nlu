<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<html>
<head><title>Translations between  RDF+OWL, N3, KIF, UML, FL, FCG and FE</title>
   <!-- to do: add CGIF, CGLF, KM -->
<meta name="ROBOTS" content="NOFOLLOW"/>
<link rel="start" href="http://www.webkb.org">
<meta name="Author" content="http://www.phmartin.info">

<style type="text/css">
@media print
{ H2               {page-break-before: always;}
  .pageBreakBefore {page-break-before: always;}
  .pageBreakAfter  {page-break-after : always;}
  xmp, pre         {page-break-inside: avoid; font-size: 10;}
  .hidden          {display: none;}
}
</style>
<script language="javascript">
<!--
function clickOn_hideOrSelect (/*aCheckbox,*/elemClass)
{ //alert("aa"); //alert(aCheckbox.checked); 
  var elems=document.getElementsByTagName("div");  var l=elems.length;
  if (!l) { alert("no elem of class "+elemClass+" found"); return; }
  for (var i=0; i< l; i++)
    if (elems[i].className==elemClass)
    { //alert(elems[i].style.display);
      if (elems[i].style.display=="none") elems[i].style.display="block";
      else elems[i].style.display="none";
    }
}
/*OLD: Hide <select name="elemToHideChoice" onClick="clickOn_elemToHideChoice(this)">
       <option value="-">---- Select to hide ---  <option value="RDF">RDF  </select>
function clickOn_elemToHideChoice (selArray)
{ var elemId= selectedValueInSelectArray(selArray); //alert(choice);
  if (elemId!="-") 
  { var elem=document.getElementById(elemId); 
    if (elem.style.visibility=="hidden") elem.style.display="visible";
    else elem.style.visibility="hidden";
  } */
//end script -->
</script>
</head>
<!-- to do: - check the @@@, creators, N3, visible XML comments,
              done: check the /> for single tags, abbrev (^), cardin []
            - tag by language
            - download orig in comparisons-orig.htm
Regarding RDF, see also
- A Revised Architecture for Semantic Web Reasoning? Peter F. Patel-Schneider
  http://www-db.research.bell-labs.com/user/pfps/publications/architecture.pdf
  lCG 1848
- Representing Disjunction and Quantifiers in RDF (2002) Drew McDermott, Dejing Dou
   RDF asserts all its subgraphs so no direct (as in OWL) repr of disjuctions
  p12, like Sowa: complexity of notation is no pb, RDF will include KIF
  p14 critical that better surface notations be found
myths: 1) low complexity; 2) readbility !important, 3) XML based
-->
<body bgcolor="white"><form>
<h4 align="center">Knowledge Representation/Translation in RDF+OWL, N3, KIF, UML and<br>
    the WebKB-2 languages (For-Links, Frame-CG, Formalized English)</h4>
   <!-- to do: add CGIF, CGLF, KM -->

<h5 align="center">Dr Philippe Martin</h5>
<!-- May/June 2003, updated with N3 in November 2006 and reorganised/completed in May 2007 -->

<h5 align="center">(Note: this is a work in progress; many parts need to be refined)</h5>

<NOSCRIPT>
<p><b>You need to enable Javascript (see the Preferences options of your browser)
      if you want to  hide the translations and explanations for certain languages.</b></p><br>
</NOSCRIPT>

<small><!--<p><br>
Unselect to remove from this document:<br>&nbsp;
overly simple examples<input  type="CHECKBOX" checked onClick="clickOn_hideOrSelect('simple');">
&nbsp; &nbsp;
synthesis examples<input  type="CHECKBOX" checked onClick="clickOn_hideOrSelect('synthesis');">
&nbsp; &nbsp;
notes on each language<input  type="CHECKBOX" checked onClick="clickOn_hideOrSelect('note');">
-->
<script language="javascript">
<!--
if (!parent.resultFrame)
{ document.write(
  '<p>Unselect languages to remove the representations/explanations related to them:<br>&nbsp;\n'
 +'FE<input  type="CHECKBOX" checked onClick="clickOn_hideOrSelect(\'FE\');">&nbsp; &nbsp;\n'
 +'FL<input  type="CHECKBOX" checked onClick="clickOn_hideOrSelect(\'FL\');">&nbsp; &nbsp;\n'
 +'FCG<input type="CHECKBOX" checked onClick="clickOn_hideOrSelect(\'FCG\');">&nbsp; &nbsp;\n'
 +'N3<input  type="CHECKBOX" checked onClick="clickOn_hideOrSelect(\'N3\');">&nbsp; &nbsp;\n'
 +'KIF<input type="CHECKBOX" checked onClick="clickOn_hideOrSelect(\'KIF\');">&nbsp; &nbsp;\n'
 +'RDF+OWL<input type="CHECKBOX" checked onClick="clickOn_hideOrSelect(\'XOWL\');">&nbsp; &nbsp;\n'
 +'KRF<input type="CHECKBOX" checked onClick="clickOn_hideOrSelect(\'KRF\');">&nbsp; &nbsp;\n'
 +'UML<input type="CHECKBOX" checked onClick="clickOn_hideOrSelect(\'UML\');"><br>\n'
 +'Comparing languages by repetitively selecting/unselecting languages is eased by the '
 +'<a href="comparisons-frames.html">frame-based&nbsp;interface</a>.</p>');
}
//end script -->
</script>

</small>
</form>



<p><br><b>Table of Contents</b>
<ol>
<li><a href="#languages">Knowledge Representation Languages</a></li>
<li><a href="#existential">Existential Quantification, Conjunction, Relations, Functions</a></li>
<li><a href="#contexts">Contextualizations (meta-statements)</a></li>
<li><a href="#identities">Identities, Names and Authorship</a></li>
<li><a href="#universal">Universal Quantification, Definitions, Implications</a></li>
    <ol><li><a href="#link">Simple Definition/Assertion Via Relations-From/To-a-Class</a></li>
        <li><a href="#definitions">Definition</a></li>
            <li><a href="#signature">Domain, Range and Cardinality of Relations</a></li>
            <li><a href="#spec">InstanceOf, SubtypeOf and Subtype Partition</a></li>
            <li><a href="#nonBinary">Non-binary relations</a></li>
            <li><a href="#declExample">Synthesis: a Typical Example</a></li>
            <li><a href="#shortcut">Relations-From/To-a-Class Used As Shortcuts</a></li>
            <li><a href="#lambda">Lambda Abstractions, Qualitative Valuation</a></li>
        </ol>
<li><a href="#numerical">Numerical Quantification</a></li>
<li><a href="#isolatedCollections">Alternatives and Isolated Collections</a></li>
<li><a href="#negations">Negation, Difference, Exclusion, Complement, Reverse</a></li>
<li><a href="#collections">Relations from Collections and Quantifier Precedence</a></li>
<li><a href="#higherOrder">Higher-order Statements</a></li>
<li><a href="#measuresAndIntervals">Ontology-dependent Representations</a></li>
    <ol><li><a href="#measures">Measures</a></li>
        <li><a href="#intervals">Intervals</a></li>
        <li><a href="#qualitative">Qualitative Valuations</a></li>
    </ol>
<!-- <li><a href="#versions">Relation Between Ontology Versions</a></li> -->
</ol>



<p><br><br><a name="languages"></a><h2>1. Knowledge Representation Languages</h2>

<p><b>General terminology.</b><br>
In this document, an <i>ontology</i> is a set of partial or 
complete machine-readable <i>definitions</i> for "formal terms" referring to objects
("resources" in OWL/RDF/XML terminology). Objects are either represented as
<i>classes</i> (i.e., <i>types</i>: concept types or relation types) or
<i>individuals</i> (types can have instances, individuals cannot).
The&nbsp;definitions associated to a formal term can be used as semantic
constraints for checking its use in other knowledge representation statements.
<i>Statements</i> are either <i>definitions</i> (partial or complete definitions)
or </i>assertions</i> (e.g., facts, data, beliefs or hypothesis).
Like assertions, definitions can be used for knowledge inferencing.
UML data models can be viewed as ontologies but their roles is (also) to prescribe
how and which individuals <i>should be entered</i> by users rather than simply
<i>describing</i> some relationships between some objects of a world. Hence,
compared to ontologies, data models require additional kinds of constraints.
However, apart from highlighting this rarely noted distinction between 
"knowledge description constraints" and "knowledge entering constraints", this
document does not propose special (ad-hoc?) representations for the
latter constraints since they are not dealt with in the "knowledge representation"
litterature.

<p><b>Goal.</b> This document was originally intended to extend UML in order to cover
common knowledge representation features useful to write definitions or assertions, and
for each feature the mapping with other models and notations is illustrated:
notations using the OWL model, KIF-based notations, and high-level notations
from WebKB-2.
<b>However, the mapping with UML proved difficult: in the various cases below,
UML <i>examples</i> are given instead of the exact <i>translations</i> of what is
expressed in the other languages (i.e, notations + models).</b>
The <a href="http://www.omg.org/docs/ad/05-08-01.pdf">OMG's ODM</a> (Ontology Definition Metamodel)
proposes partial (and sometimes total) structural mappings between UML, OWL, ER, CL and Topic Maps.
<!-- See ODM http://www.omg.org/docs/ad/05-08-01.pdf
P 50  8.4.3 Mappings
Working with multiple metamodels will often require a model element by model element translation of model instances from one metamodel to another. We have seen that UML profiling has limited capability in representing ODM metamodels in UML. We therefore need to specify mappings from one metamodel to another.
There is a parallel RFP in the OMG called QVT (Query/View/Transform) which will provide a standardized MOFbased platform for mapping instances of MOF metamodels from one metamodel to another [QVT]. Although the QVT specification is not yet final, it appears to be sufficiently mature that we have used it to define the mappings in the ODM.  //pm: Chapter 14 (ER) says this is still the future 
Translation between metamodels has the fundamental problem that there may not be a single and separate model element in the target corresponding to each model element in the source (indeed, if the metamodels are not simply syntactic variations, this would be the normal situation). We will call this situation structure loss. Some of the issues involved with structure loss and what to do about it using one of the earlier QVT proposals are discussed in [MSDW].
An overview of the mapping strategy used in the ODM is illustrated in Chapter 9. Note that there are mappings from each metamodel to and from OWL Full, except for Common Logic (CL) for which there is only a mapping from OWL Full. A lossy, reverse mapping defined in QVT from CL to OWL, and bi-directional mappings between UML and CL are planned, and will be added either during finalization or through an RFP/RFC process.

[SCL Translation] Translating Semantic Web Languages into SCL, Patrick Hayes, IHMC, November 2004. Latest
version available at http://www.ihmc.us/users/phayes/CL/SW2SCL.html.
-->
<!--Hence, t-->This document is essentially a case-by-case comparison of OWL, KIF, their usual
notations, and higher-level notations.
<b>If you wish one more language to be compared here</b>, send me the translations in this
language of the examples given below and I'll include them (citing you as author
of these translations).
<!-- //********** N3 important links:
Notation 3 Resources:                              http://www.w3.org/DesignIssues/N3Resources
Primer: Getting into RDF & Semantic Web using N3:  http://www.w3.org/2000/10/swap/Primer.html
Rules and Formulae:                                http://www.w3.org/2000/10/swap/doc/Rules
Examples (e.g., transitive in "making rules"):      http://www.w3.org/2000/10/swap/Examples
N3 contexts (best):                http://www.ninebynine.org/RDFNotes/UsingContextsWithRDF.html

See also Turtle (an extension of the N-Triples), a subset of N3 for RDF, 
   at http://www.dajobe.org/2004/01/turtle/#sec-diff-n3

FL==FwQiC(with Quantifier in Contexts), FCG/CG==FwQiN
Language
  language using variables for quantifying/connecting concept nodes 
    KIF CGIF 
    good: simple/regular/explicit/scalable syntax
    bad: hard to relate (hence, hard to read)
  language able not to use variables for quantifying/connecting nodes (graph-like notation)
    good: more readable than KIF
    bad: precedence rules to define/explicit
    language putting quantifiers in nodes (nearby type)
      CGLF FCG FE CGIF KM N3 RDF (although no explicit quantif. in RDF)
      good: more readable if many quantified subnodes
      bad: redundancy/replication;  difficult to visually compare/merge
    language putting quantifiers in relation nodes' context
      FL (context after dest node; nearby rel. type is bad solution)
      good: more readable if not many quantified subnodes, no redundancy/replication
 -->

<p><b>KIF, OWL, and their notations.</b><br>
<a href="http://www-ksl.stanford.edu/knowledge-sharing/kif/">KIF</a> refers to
   <!-- and http://logic.stanford.edu/kif/dpans.html --> a Fist-Order Predicate Calculus (FOPC)
based model and its LISP-based notation. KIF has been designed and used to specify
the logical denotation of many other knowledge representation languages (KRLs). KIF
is the current de-facto standard for knowledge interchange, and is the notation and
basis used by the main knowledge sharing international projects of the knowledge 
representation community: <a href="http://cl.tamu.edu/">Common Logic</a>,
<a href="http://suo.ieee.org/">SUO and IFF</a>.<br>
<!--     http://www.w3.org/TR/owl-guide/ -->
<a href="http://www.w3.org/TR/owl-features/">OWL</a> is a model that
follows the principles of terminological logics languages and hence frame-based languages.
OWL includes the RDF and RDFS model. OWL can be represented in KIF (the reverse is false).
OWL and its <a href="http://www.w3.org/TR/REC-rdf-syntax/">RDF/XML</a> notation are
W3C recommendations (from now on and except when the expression "OWL model" is used,
references to OWL <i>also</i> refer to RDF/XML, the RDF model and its extension named
RDFS). <a href="http://www.w3.org/DesignIssues/Notation3.html">Notation&nbsp;3</a> (or N3)
is a syntax sometimes used as a more readable alternative to RDF/XML; it is more
expressive than RDF/XML but less than KIF.
<br>The RDF model and the OWL model are <i>language ontologies</i>: like
metamodels, they propose formal terms for concepts and relations (e.g., subtypeOf)
that are necessary to express statements regardless of what the statements
express. KRLs such as KIF make their language ontologies implicit.
<i>Content ontologies</i> are like models, i.e., they contain formal terms
referring to objects in the modeled real/imaginary world.
RDF/XML is an XML textual notation for statements using the RDF metamodel.
Statements using the OWL metamodel are usually written using RDF/XML but they
can also be written in KIF: these two notations are used below and respectively
named XOWL and KOWL. More precisely, since the OWL model can be divided into
three increasingly expressive metamodels - OWL lite, OWL DL and OWL full - the
least expressive part of OWL involved will be specified by using the terms XOWLL,
XOWLD, XOWLF, KOWLL, KOWLD and XOWLF.


<p><b>Higher-level languages.</b><br>
Knowledge entering and sharing requires higher-level languages
(models+notations) than OWL and KIF. Here, "higher-level" means more user-friendly
and more "normalizing", i.e., restricting the number of ways something can be
expressed.
This is achieved by providing (linear or graphic) graph-based expressive languages
with high-level constructs such as extended quantifiers (e.g., "at least 65%",
"most" and "2 to 4"). Below, the high-level notations used below are
used in the <a href="http://www.webkb.org">WebKB knowledge server</a>:
<a href="../F_languages.html#FE">Formalized English&nbsp;(FE)</a>,
<a href="../F_languages.html#FCG">Frame-CG&nbsp;(FCG)</a> and
<a href="../F_languages.html#FL">For-Links&nbsp;(FL)</a> (since FL is more
adequate for taxonomies, FL and FCG/FE will rarely be presented as alternatives
for translations).
These notations [<a href="../papers/iccs02">Martin 2002</a>] were mainly derived
from the original linear form of the
<a href="http://www.cs.uah.edu/~delugach/CG/">Conceptual Graph</a> model
[<a href="#Sowa92">Sowa 1992</a>] and to a less extent, Frame-Logics and KIF.
The WebKB model [<a href="../papers/iccs01/">Martin 2001</a>] is an extension and
normalization of the CG model. I have converted this model into a
<a href="http://www.omg.org/docs/formal/06-01-01.pdf">MOF2</a> metamodel and named it "<a href='KRM.html'>KRM</a>".
Its MOF HUTN format, which I named "KRF", is one of the formats used below
<!--, along with OCL,--> when UML needs to be extended.





<p><br><br><a name="existential"></a><h2>2. Existential Quantification, Conjunction, Relations, Functions</h2>
<p>A "conjunctive existentially quantified statement" is a set of existentially 
quantified objects (named or anonymous objects) possibly connected by relations.
Such statements are very common and nearly all KRLs permit to represent them.
They also have a nice property: the generalization of such a statement (a simple
and common graph operation consisting of replacing an individual in the statement
by a class or a class by one of its superclass, or by removing a relation) is a
logical deduction [Sowa, 1984]. Hence conversely, looking for such specializations
of such a statement/query retrieve "logical" answers.
This property can be extended to such statements with positive contexts (see next
section) [Chein and Mugnier, 1997] or distributive sets but not to statements 
including some universal quantification, negation, modality, OR relation, OR-set,
etc. Looking for specializations of the last cases is still a simple way to 
retrieve "interesting" answers (e.g., "john thinks there is no employee under 25" 
in answer to "is there an employee under 30?") but these are not "logical" answers.

<p>Here is an example. From now on and until the "Definition" Section, for 
readability reasons, object names are most often used instead of identifiers. 
Furthermore, the creator of each statement is not represented since an additional 
context would be required for that. "FE" is for Formalized English.

<div class="E"><pre>
E:     Tom owns a dog that is not Snoopy.
</pre></div><div class="FE"><pre>
FE:    Tom is owner of a dog different_from Snoopy.
</pre></div><div class="FCG"><pre>
FCG:   [Tom, owner of: (a dog != Snoopy)]
</pre></div><div class="KIF"><pre>
KIF:   (exists ((?x dog)) (and (owner ?x Tom) (/= ?x Snoopy)))
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;Dog>&lt;owner>&lt;owl:Thing rdf:about="#Tom"/>&lt;/owner>
         &lt;owl:differentFrom rdf:resource="#Snoopy"/>&lt;/Dog>
</pre></div><div class="N3"><pre>
N3:    [a :Dog; :owner :Tom;  owl:differentFrom :Snoopy].
</pre></div><div class="KRF"><pre>
KRF:   TNode{term:Tom sourceOf:
         Relation{rType:owner dest: QNode{cType:dog sourceOf:
           Relation {rType: different_from dest: TNode{term:Snoopy} }}}}.
</pre></div><div class="UML"><p>Related simple example in UML:<br>
<center><table border="1" cellspacing=0 cellpadding=5>
           <tr><td><img src="umlIndividual.jpg"></td></tr></table><br>
   <i>Example of Conjunctive Existentially Quantified Sentence<br>
      <small>(excerpt from <a href="http://hcs.science.uva.nl/usr/Schreiber/docs/owl-uml/owl-uml.html">Schreiber's OWL translation in UML</a>)</small></i></center></div>



<p><br><br><a name="contexts"></a><h2>3. Contextualizations (meta-statements)</h2>

<p>Contexts permit to represent statements over statements, and hence, for example,
situation duration and statement negation, modalities, creator and argumentation
relations. Contextualised statements are represented via delimitors such
as '(...)&nbsp;and ^(...)&nbsp;in KIF or keywords (e.g., <code>aboutEach</code> in RDF/XML 
and hence OWL. In FCG and FE, statements always have delimitors (`...'&nbsp;in FE,
[...]&nbsp;in FCG) and the context of a statement may be specified by adding a list of
relations (delimited by a pair of parenthesis). These relations are about the statement,
or in other words, about each relation of the statement.

<p>Given the ill-designed RDF model and syntax (ill-designed mostly because of the difficulties
created by the choice of a triple-based model and an XML syntax), the meaning
and use of <code>aboutEach</code> is often problematic; the
<a href="http://www.w3.org/TR/rdf-syntax-grammar/">W3C Working Draft
of 23/01/2003</a> revising the
<a href="http://www.w3.org/TR/REC-rdf-syntax/">W3C Recommendation of 22/02/1999
about RDF/XML</a> removed <code>aboutEach</code> from the grammar. However,
since it has not (yet) been replaced, any practical way to represent relations
from statements or collections with RDF/XML has also been removed.
Given these are basic and unavoidable features of knowledge/ontology
representation, this removal is one more evidence that RDF/XML (and indirectly
OWL) is totally unfit for such purpose. In order to present translations in OWL,
this removal of <code>aboutEach</code> is ignored below (thus, the assumption
is that a similar construct will one day be introduced as a replacement).

<p>In the following example, to represent the negation of a statement in OWL,
an intermediary class is created for this statement and then an instance
of the complement of this intermediary class is refered to. Although syntactically
correct, it is doubtful that an inference engine will be able to exploit such an
indirection any time soon.
<div class="E"><pre>
E:     Tom believes Mary likes him (now) in 2003, and that before she did not.
</pre></div><div class="FE"><pre>
FE:    Tom is believer of ` *p `Mary is liking Tom' at time 2003'
       and is believer of `!*p is before 2003'.
</pre></div><div class="FCG"><pre>
FCG:   [Tom, believer of: [*p [Mary, agent of:(a liking,object:Tom)], time:2003],
             believer of: [!*p, before: 2003] ]
</pre></div><div class="KIF"><pre>
KIF:   (exists (?p)
         (and (= ?p '(exists ((?x liking)) (and (agent *l Mary) (object ?l Tom))))
              (believer ^(time ,?p 2003) Tom)
              (believer ^(before (not ,?p) 2003) Tom)))
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;rdf:Description rdf:bagID="p">
         &lt;Liking>&lt;agent>&lt;rdf:Description rdf:about="#Mary"/>&lt;/agent>
                 &lt;object rdf:resource="#Tom"/>&lt;/Liking>&lt;/rdf:Description>
       &lt;rdf:Description rdf:bagID="now"  rdf:aboutEach="#p"  time ="2003"/>
       &lt;owl:Class rdf:bagID="class_of_not_p">
         &lt;owl:complementOf rdf:parseType="Collection">
           &lt;owl:Class>&lt;owl:oneOf rdf:parseType="Collection">
              &lt;owl:Thing rdf:about="#p"/>&lt;/owl:oneOf>
           &lt;/owl:Class>&lt;/owl:complementOf>&lt;/owl:Class>
       &lt;class_of_not_p rdf:bagID="not_p"/>
       &lt;rdf:Description rdf:bagID="past"  rdf:aboutEach="#not_p"  before="2003"/>
       &lt;rdf:Description rdf:aboutEach="#now">&lt;believer rdf:resource="#Tom"/>
       &lt;/rdf:Description>
       &lt;rdf:Description rdf:aboutEach="#past">&lt;believer rdf:resource="#Tom"/>
       &lt;/rdf:Description>
</pre></div><div class="N3"><pre>
N3:    {{[a :Liking;  :agent :Mary; :object :Tom]} rdf:ID :p;  :time "2003"} believer :Tom.
       :not_p negation :p.  {:not_p :before "2003"} believer :Tom.
</pre></div><div class="KRF"><pre>
KRF:   TNode {term:Tom
         sourceOf:isReversed Relation{rType:believer dest:
           ENode {embeddedNode1: ENode part: {embeddedNode1:
                    TNode{term:Mary sourceOf:isReversed
                      Relation{rType:agent dest: QNode{cType:liking sourceOf:
                        Relation{rType:object dest: TNode{Term:Tom} }}}}}
                  sourceOf:Relation{rType:time dest:
                    QNode{cType:"year" quantifier:Quantifier{num:"2003"}}}}}
         sourceOf:isReversed Relation{rType:believer dest:
           ENode {embeddedNode1: isNegated ENode {embeddedNode1Ref: p}
                  sourceOf: Relation{rType:before dest:
                  QNode{cType:year quantifier:Quantifier{num:"2003"}}}}}}
</pre></div>




<p><br><br><a name="identities"></a><h2>4. Identities, Names and Authorship</h2>
<!-- <br>An ontology may relate an object to various <i>identifiers</i> and 
various <i>names</i> (an identifier refers to only one object; a name is just a
<i>word</i>, it can have various meanings and hence can refer to various objects;
names referring to a same object are "synonyms"). Thus, like in a thesaurus,
an ontology may include lexical relations between words. However, an ontology
also includes semantic relations between objects, typically generalization
relations (i.e., subtypeOf and instanceOf). An ontology that includes lexical
relations and only direct semantic relations between objects (i.e., no 
complex definitions) are often called "lexical ontologies". The lexical database
<a href="http://wordnet.princeton.edu/">WordNet</a> can be seen as a
lexical ontology and is now often used as such.
A thesaurus (generally) does not distinguish between objects (classes and 
individuals) and words, and therefore does not include semantic relations.
Hierarchy structured catalogs which do not <i>explicitely</i> specify the
relations linking the (types of the) objects of the catalogs are not ontologies.
Typical examples are the domain/subject catalogs of Web search engines such as 
Yahoo: within a same hierarchy, they use and many relations <i>implicitely</i>,
i.e., without specifying their exact types, e.g., subtypeOf, instanceOf, partOf or
memberOf.
-->

<p>An <b>identity</b> relation may be seen as specifying that two classes are
identical, or from another viewpoint, as a way to associate various identifiers
to a same object.</p>
<!-- An example of identity relation between classes is first shown.
    <code>pm</code> is a constant that refers to the person that has for identifier
    <code>pmartin@dstc.edu.au</code>. -->
<!--
    "E" is for "English". "//" introduces a line comment for people only (i.e.,
    discarded by parsers). The OWL notations below use the XML comment marks
    "&lt;!-- ... --&gt;" for such comments. They also use RDF/XML namespace
     shortcuts, e.g., they do not refer to <code>owl#nothing</code> but either to 
     <code>owl:Nothing</code> or to <code>&amp;owl;Nothing</code>, depending on
     where the identifier is used. -->

<div class="XOWL">In this document, an ad-hoc representation is used for representing
authorship in RDF/XML (as in the example below): the relation/property 
<code>dc:creator</code> is used in the same way <code>xml:lang</code> is used in XML,
that is, as if it was a special XML attribute of another property. Using a metastatement
(as in the previous section) would be more correct but would reduce too much the readability
(and hence understandability) of the given <i>examples</i>.
</div>

<p><!-- <i>(In the following example, replacing pm#nothing, owl#nothing and kif#bottom,
by respectively pm#array, bob#array and kr#table might lead to a more
understandable but this one is more typical (and does not need to introduce bob
nor kr)).</i> --> <code>bottom</code> is a constant in KIF; in the other notations, the
identifier <code>kif#bottom</code> is used.</p>

<div class="E"><pre>
E:     According to pm, pm#nothing is identical to owl#nothing,
       and according to Joe, owl#nothing identical to kif#bottom.
</pre></div><div class="FL"><pre>
FL:    pm#nothing   =  owl#nothing (pm)  kif#bottom (Joe);
</pre></div><div class="FCG"><pre>
FCG:   [pm#nothing, = owl#nothing](pm);  [pm#nothing, = kif#bottom](Joe);
</pre></div><div class="KIF"><pre>
KIF:   (dc#Creator '(= pm#nothing  owl#nothing) pm)
       (dc#Creator '(= pm#nothing  bottom) Joe)
</pre></div><div class="KIF"><pre>
KOWLL: (dc#Creator '(owl#equivalentClass pm#nothing owl#nothing ) pm) 
       (dc#Creator '(owl#equivalentClass pm#nothing bottom) Joe) 
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;owl:Class rdf:about="&pm;Nothing">
         &lt;owl:equivalentClass rdf:resource="&kif;Bottom" dc:creator="Joe"/>
         &lt;owl:equivalentClass rdf:resource="&owl;Nothing" dc:creator="pmartin@dstc.edu.au"/>
       &lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    {pm:Nothing owl:equivalentClass kif:Bottom}  dc:creator "Joe".
       {pm:Nothing owl:equivalentClass owl:Nothing} dc:creator "pmartin@dstc.edu.au".
</pre></div><!-- <div class="UML"><pre>        
UML:   //image of identity associations with creator, linking the 3 classes
</pre></div><div class="KRF"><pre>
KRF:   Type "pm#nothing" { equal:"owl#nothing"  equal:"kif#bottom" }  //+pm
</pre></div> -->

<p>For relations between relation types (i.e., between "properties" in
OWL terminology), OWL Lite requires the use of 
<code>owl#equivalent_property</code> instead of <code>owl#equivalent_class</code>.
Similarly, for relations between individuals, OWL Lite requires the use of 
<code>owl#same_individual_as</code>. In all cases, <code>owl#same_as</code> may
be used instead in OWL Full, and there is no change in the other notations;
<code>owl#same_as</code> may only be used in OWL Full because it asserts
equality (identity) not simply equivalence.


<p><br>Although <b>names</b> are not definitions, identifiers are also names and
hence, it is suitable to detail now how names can be associated to objects.
<div class="E"><pre>
E:     There is a class named "dog" and "domestic_dog" by wn, and "doggy"
       and "chien" by pm; "dog" is a key name for wn; "chien" is a French name.
</pre></div><div class="FL"><pre>
FL:    wn#dog__domestic_dog  name: "doggy" (pm) "chien" (pm, language: wn#French);
</pre></div><div class="KIF"><pre>
KOWLL: (dc#Creator '(rdfs#label wn#dog "dog") pm)  ;;"class" not represented
       (dc#Creator '(rdfs#label wn#dog "dogmestic_dog") wm)
       (dc#Creator '(rdfs#label wn#dog "doggy") pm)
       (dc#Creator '(xml#lang '(rdfs#label wn#dog "chien") fr) pm)
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;owl:Class rdf:about="&wn;dog">
         &lt;rdfs:label dc:Creator="http://wordnet.princeton.edu/">dog&lt;/rdfs:label>
         &lt;rdfs:label dc:Creator="http://wordnet.princeton.edu/">domestic_dog&lt;/rdfs:label>
         &lt;rdfs:label dc:Creator="pmartin@dstc.edu.au">doggy&lt;/rdfs:label>
         &lt;rdfs:label xml:lang="fr" dc:Creator="pmartin@dstc.edu.au">chien&lt;/rdfs:label>
       &lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    {wn:dog rdfs:label "dog", "domestic_dog"} dc:creator "http://wordnet.princeton.edu/".
       {wn:Dog rdfs:label "doggy"} dc:creator "pmartin@dstc.edu.au".
       { {wn:Dog rdfs:label "chien"} xml:lang "fr"} dc:creator "pmartin@dstc.edu.au".
</pre></div><!-- </div><div class="UML"><pre>        
UML:   //image of name associations with creator?
</pre></div><div class="KRF"><pre>
KRF:   Name "wn#dog" {s:"dog"  nameSpace:User wn}
       Name "wn:domestic_dog" {s:"domestic_dog"  nameSpace:User wn}
       Name "pm:doggy" {s:"doggy" nameSpace:User pm} 
       Name "pm:chien" {s:"chien" nameSpace:User pm}  //"French" not represented
       Type "dog" { identifier: Name "wn#dog"  name: Name "wn:domestic_dog"
                    name: Name "pm:doggy"      name: Name "pm:chien" }
</pre></div> -->







<p><br><br><a name="universal"></a><h2>5. Universal Quantification, Definitions, Implications</h2>

<p><b>Distinctions between assertions and definitions.</b><br>
Definitions differ from assertions-using-a-universal-quantifier in the sense
that definitions cannot be false. For example, defining a class with name
"rectangle" as a kind of car is not false, even if "rectangle" is not an 
intuitive name for a class of car. However, like an assertion, a new definition
may happen to be inconsistent with already entered definitions or assertions.
In such a case, various strategies can be used. In a multi-user Knowledge Base 
Management System (shared KBMS), the new definition may be denied (i.e.,
the user has to associate its definition to a more appropriate class) or
accepted (then, in order to keep the knowledge base consistent and according to
the new definition, a more appropriate class must be automatically created,
given an identifier and inserted into the class generalization hierarchy).
For the management of shared knowledge (in a cooperatively built KB or in
a KB automatically built by collecting knowledge from various private KBs),
it is important that the creator of each object, relation or statement can be
formally associated to them, either manually by the knowledge provider or
automatically (then, knowledge filtering can be done on the creators, using their
identifiers, superclasses or statements about them). Since this is one of
the (many) things RDF/XML is not tailored for, comments will simply be used in the
OWL-related translations (the "Context" section will also show how creators
can be associated in more formal but ad-hoc ways to RDF/XML representations).
<!-- The definition of a formal term which as not been defined before is also a
declaration. -->
<br>A class definition is complete if it specifies necessary and sufficient 
conditions for objects to be instance of the class, or partial if it specifies
either necessary or sufficient conditions. Setting a relation subtypeOf from a
class to another is a simple way to define one necessary condition for the source 
class, and one sufficient condition for the destination class. (However, if this
relation is set by someone who has not created the source/destination class,
the relation may be treated as an assertion rather than a definition for
knowledge inferencing/checking and inconsistency handling purposes).
This document first lists simple definitions/assertions via such
"relations-from/to-a-class", then presents various features for
expressing statements (definitions or assertions), and concludes with a section
on definitions using such features. In the first and last sections,
only identifiers will be used for objects. In the other sections, for maximum
readability, object names will often be used instead of object identifiers, but
statements will still be asumed unambiguous (either because each name happens
to refer to only one object or the ambiguity can be automatically resolved by
exploiting semantic constraints, e.g., relation signatures). In a KBMS,
ambiguous statements should not be accepted.




<p>Universal quantification does not exist in OWL but using class definitions
is close enough. The difference is that a universal statement can be false
whereas definitions cannot (a definition does not assert a fact but only lists
conditions for membership to a class and thus is neither true nor false but
some people say that a definition is "always true, by definition").
Furthermore, when two users give conflicting definitions about a same class,
this can be adequately resolved by creating two different classes (since the
conflict reveals that the authors of the definitions do not think about the
same concept/object), whereas resolving conflicting assertions (or beliefs
when each assertion has a creator) implies selecting between them (or none 
of them) and this is a matter of trust or strategy (e.g., the simple strategy 
of always selecting the most specialized assertion).

<p>The following example requires OWL Full because <code>part</code> is a
transitive relation. Otherwise, OWL Lite would have been sufficient (the used
cardinality is not more than 1).
<div class="E"><pre>
E:     Animals have exactly one head.
</pre></div><div class="FE"><pre>
FE:    Any animal has for part 1 head.
</pre></div><div class="FCG"><pre>
FCG:   [any animal, part: 1 head]
</pre></div><div class="KIF"><pre>
KIF:   (forall ((?a animal)) (exists1 '?h (and (head ?h) (part ?a '?h))))
</pre></div><div class="XOWL"><pre>
XOWLF: &lt;rdf:Property rdf:ID="headPart">
         &lt;rdfs:subPropertyOf rdf:resource="#part"/>
         &lt;rdfs:range rdf:resource="#Head"/> &lt;/rdf:Property>
       &lt;owl:Class rdf:about="#Animal">
         &lt;rdfs:subClassOf>&lt;owl:Restriction>
           &lt;owl:cardinality rdf:datatype="&xsd;nonNegativeInteger">1
           &lt;/owl:cardinality> &lt;owl:onProperty rdf:resource="#headPart"/>
                          &lt;/owl:Restriction>&lt;/rdfs:subClassOf>&lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    :headPart a rdf:Property;  rdfs:subPropertyOf :part;  rdfs:range :Head.
       :Animal rdfs:subClassOf
          [a owl:Restriction;  owl:onProperty :headPart;  owl:cardinality 1]. 
</pre></div><div class="KRF"><pre>
KRF:   QNode {cType:animal quantifier:Quantifier{kind:any}
         sourceOf: Relation {rType:part dest:
           QNode {cType:head quantifier:Quantifier{num:"1"}}}}
</pre></div><!--OCL:,  UML:   here, cardinalities can be used as in OWL-->

<p>Here is a KIF definition of <code>exists1</code>:<br>
<code>(defrelation exists1 (?var ?predicate) :=<br>
&nbsp; (truth ^(exists (,?var)<br>
&nbsp; &nbsp; (and (,?predicate ,?var)
                   (forall(?y) (=> (,?predicate ?y) (= ,?var ?y)))))))</code>









<p><br><br><a name="definitions"></a><h3>Definition</h3>

<p>A class (concept type or relation type) definition states necessary
and/or sufficient conditions for objects to be instance of this class.
Some KRLs (but not OWL nor KIF) also accept "prototypes" (as in 
"a prototypical bird is able to fly"). Since I advocate the use of extended
quantifiers, I think that statements using the "most" quantifier
(or a more precise one, e.g., "78%") and contexts (e.g., to specify the location
and time, as in "'78% of birds are able to fly' in australia, in 2003")
should be used instead of prototypes.

<p>Any statement (using any of the above presented features) can be
used in a definition. However, inference engines can only use simple definitions
to categorize classes into a generalization hierarchy, or find the most
specialized class (or classes) for an object according to the statements
using it (or in frame-based terminology, according to the properties
associated to it).

<p>Setting a subtypeOf relation from a class to another is a way to give
necessary conditions for the source class and sufficient conditions for the 
destination class. In OWL, this is the only way in OWL, and the use of
temporary classes called "restrictions" (some restricted forms of 
lambda-abstractions) plus relations such as <code>owl#intersection_of</code>,
<code>owl#union_of</code> and <code>owl#complement_of</code> permit to create
complex definitions. The direct use of these three relations,
<code>owl#equivalent_class</code>, <code>owl#equivalent_property</code> or
<code>owl#inverse_of</code> actually define necessary <i>and</i> sufficient
conditions. Thus, the following example of a partial definition can be
changed into a complete definition by replacing "rdfs:subClassOf" by
"owl:equivalentClass" in the OWL translations (and ":=>" by ":=" in FCG and
KIF). As announced in the first section, class identifiers are now used instead
of class names in the examples.
<div class="E"><pre>
E:     According to "pm", a person necessarily has for parent a person.
</pre></div><div class="FCG"><pre>
FCG:   [type wn#person (*x) :=> [*x, pm#parent: a wn#person] ](pm)
</pre></div><div class="KIF"><pre>
KIF:   (dc#Creator '(defrelation wn#person (?p) :=>
                      (exists ((?p2 #person)) (pm#parent ?p ?p2))) pm)
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;owl:Class rdf:about="&wn;Person">
         &lt;rdfs:subClassOf>&lt;owl:Restriction>
                            &lt;owl:onProperty rdf:resource="&pm;parent"/>
                            &lt;owl:toClass rdf:resource="&wn;Person"/>
                          &lt;/owl:Restriction>&lt;/rdfs:subClassOf>
         &lt;rdfs:comment>According to pmartin@dstc.edu.au&lt;/rdfs:comment>
       &lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    {wn:Person rdfs:subClassOf
           [a owl:Restriction; owl:onProperty pm:parent; owl:toClass wn:Person]
       } dc:Creator "pmartin@dstc.edu.au".
</pre></div><div class="KRF"><pre>
KRF:   Definition { creator: User pm
         dType:CType person  kind:NC  parameter:("x")
         embeddedNode1: QNode {var:"x" sourceOf:Relation{rType:"pm#parent"
           dest: QNode {cType:person} }}}
</pre></div><div class="UML"><p>Related simple example in UML:<br>
<center><table border="1" cellspacing=0 cellpadding=5>
           <tr><td><img src="umlDefinedClass.jpg"></td></tr></table><br>
   <i>A definition by necessary and sufficient conditions
   <small>(excerpt from <a href="http://hcs.science.uva.nl/usr/Schreiber/docs/owl-uml/owl-uml.html">Schreiber's OWL translation in UML</a>)</small></i></center></div>


<p>In FCG and KIF, the definition of relation types is identical to the
definition of other classes except for the number of parameters (variables).
In OWL, there is no variable, and hence no syntactic means to give a
definition to a relation type (apart from indicating its superclass,
domain and range).


<p>In addition to definitions by intension, OWL permits definitions by extention.
I have not encountered such definitions in ontologies. If I do, I will extend
the FL grammar to represent them as indicated below, i.e., by accepting
"closed instance partitions".
<div class="E"><pre>
E:     The class pm#Da_Ponte_opera_of_Mozart has only three instances:
       pm#Le_Nozze_di_Figaro, pm#Don_Giovanni and pm#Cosi_fan_tutte.
</pre></div><div class="FL"><pre>
FL:    pm#Da_Ponte_opera_of_Mozart
        instance: {(pm#Le_Nozze_di_Figaro,pm#Don_Giovanni,pm#Cosi_fan_tutte)}(exclusive);
        //"{(...)}" refer to a complete AND-SET, hence here a complete "instance partition".
</pre></div><div class="FCG"><pre>
FCG:   [a pm#Da_Ponte_opera_of_Mozart,
         = OR{pm#Le_Nozze_di_Figaro,pm#Don_Giovanni,pm#Cosi_fan_tutte}]
</pre></div><div class="KIF"><pre>
KIF:   (<=> (pm#Da_Ponte_opera_of_Mozart ?x)
            (or (= ?x pm#Le_Nozze_di_Figaro) (?x pm#Don_Giovanni)
                (= ?x pm#Cosi_fan_tutte)))
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;owl:Class rdf:ID="&pm;Da_Ponte_opera_of_Mozart">
         &lt;owl:oneOf rdf:parseType="Collection">
           &lt;owl:Thing rdf:ID="&pm;Nozze_di_Figaro"/>
           &lt;owl:Thing rdf:ID="&pm;Don_Giovanni"/>
           &lt;owl:Thing rdf:ID="&pm;Cosi_fan_tutte"/>
         &lt;/owl:oneOf>&lt;/owl:Class>
         &lt;!-- the intercap style cannot be used for identifiers here
         because then they could not be translated back to other notations -->
</pre></div><div class="N3"><pre>
N3:    pm:Da_Ponte_opera_of_Mozart
         owl:oneOf (pm:Nozze_di_Figaro, pm:Don_Giovanni, pm:Cosi_fan_tutte).
</pre></div><div class="KRF"><pre>
KRF:   QNode{cType:"pm#Da_Ponte_opera_of_Mozart"
         sourceOf: Relation{rType:equal dest:
           NodeCollection{aggregation:or
             collElt: TNode{term:"pm#Le_Nozze_di_Figaro"}
             collElt: TNode{term:"pm#Don_Giovanni"}
             collElt: TNode{term:"pm#Cosi_fan_tutte"} }}}
</pre></div><div class="UML"><code>        
UML: </code><center><table border="1" cellspacing=0 cellpadding=5>
           <tr><td><img src="umlEnumerationClass.jpg"></td></tr></table><br>
<i>An enumerated class. The number "3" at the upper-right corner of the class box
   specifies that this class has exactly three instances &nbsp;
   <small>(excerpt from <a href="http://hcs.science.uva.nl/usr/Schreiber/docs/owl-uml/owl-uml.html">Schreiber's OWL translation in UML</a>)</small></i></center></div>









<p><br><br><a name="link"></a>
<h3>Simple Definition/Assertion Via Relations-From/To-a-Class</h3>

<p>An object identifier may be a URL (as in RDF/XML, e.g.,
<code>http://www.foo.com</code> and <code>http://www.bar.com/doc.html#car</code>),
an e-mail address or, within a shared KBMS for example, the composition of a
source/user identifier and a "key name" within that namespace, as in
<code>wn#electric_car</code> and <code>pm#electric_vehicle</code> (with
<code>wn</code> referring to WordNet&nbsp;1.7 and <code>pm</code> to the person
identified by <code>pmartin@dstc.edu.au</code>). This last notation is used in
WebKB-2 and will be use in the following examples. All the used identifiers
exist in the KB of WebKB-2, and their related classes (e.g., subclasses) and
statements are accessible via WebKB-2 interfaces or URLs (e.g.,
<code>../../bin/categSearch.cgi?categ=wn%23electric_car</code>).

<p>Note that a key name is also a name, and hence when an object identifier is
created with an English word/expression as key name, its orthograph or case 
should not be altered and hence, in WebKB-2, the character '_' is used as a 
connector (e.g., <code>pm#electric_vehicle</code>, not
<code>pm#ElectricVehicle</code>). This is important for the presentation of
statements in natural language or restricted languages. Without this convention, 
the correct orthograph cannot be retrieved with certainty (at least in English)
and the knowledge providers are expected to specify the correct orthograph using
an additional name ("label" in RDF/XML) which is cumbersome and, in practice,
rarely done. As shown below in the RDF/XML translations, when converting statements
to languages where other conventions have been adopted, the identifiers are
converted too. When referring to object identifiers which do not follow the
expected conventions (e.g., the "elements" of the Dublin Core are relations
but their identifiers beging by an uppercase), no orthographic change is made
(e.g., <code>dc#Creator</code> is used in all notations).

<p>In FCG, a statement of the form "[x, r: y]" means "x has for r y".
In the KIF-based notations below, a statement of the form "(r x y)" also means 
"x has for r y" (this convention is unfortunately not in the KIF documentation
and hence the opposite convention is used by some other people).



<h4><br><br><a name="signature">Domain, Range and Cardinality of Relations</a></h4>

<p>In predicate logic and semantic networks, a relation is a first-order entity,
that is, it is not "local" to an object but can be applied to any object
provided that the class of this object complies with the relevant class specified
in the signature of the relation, i.e., is identical to it, more specialized, or 
to ease query formulation, more general. Identifiers of relation types also have
no separate namespace. For clarity purposes, the expression 
"relation types" is often used as a synonym to "relation classes".

<p>Binary relations ("properties" in OWL terminology) map directly to UML
associations. In OWL, the relations <code>rdfs#domain</code> and
<code>rdfs#range</code> permit to specify the signature of a relation, while
<code>rdfs#domain</code>, while <code>owl#min_cardinality</code>,
<code>owl#max_cardinality</code> and <code>owl#cardinality</code> permit to
specify its range cardinality. Stating that a relation type is instance of the
the metaclass <code>owl#functional_property</code> or
<code>owl#inverse_functional_property</code> respectively permits to specify a
range cardinality <code>(0..1)</code> and a domain cardinality <code>(0..1)</code>.
To specify other domain cardinalities in OWL, inverse relations must unfortunately
be introduced.

<p>OWL Lite consider datatypes (e.g.,, numbers and strings) and objects having a 
class as exclusive kinds of objects. This exclusion is fortunately removed in
OWL DL and OWL Full <!-- and has no consequence apart from some syntactic clumsiness -->
but OWL distinguishes between "object properties" and "datatype properties".
Using attributes seem to be a natural way to represent "datatype properties" in UML
but this implies that an attribute is just a shortcut for an association (which
must be automatically derivable from the attribute by an UML system).

<p>Below are two examples of relation definitions.
<code>pm</code> is a constant that refers to the person that has for identifier
<code>pmartin@dstc.edu.au</code>.
"E" is for "English". "//" introduces a line comment for people only (i.e.,
discarded by parsers). The OWL notations below use the XML comment marks
"&lt;!-- ... --&gt;" for such comments. They also use RDF/XML namespace shortcuts,
e.g., they do not refer to <code>owl#nothing</code> but either to 
<code>owl:Nothing</code> or to <code>&amp;owl;Nothing</code>, depending on where
the identifier is used.

<div class="E"><pre>
E:     Relations of type pm#husband are defined as both functional and 
       inverse functional relations, from an object of class pm#woman to
       an object of class pm#man.
</pre></div><div class="FL"><pre>
FL:    pm#husband (0..1 pm#woman -> pm#man);                    //default representation;
FL:    pm#husband (0..1 pm#woman, 0..1 pm#man);                 //a more extended form;
FL:    pm#woman pm#husband: pm#man (pm, any->0..1, 0..1<-any);  //another one;
</pre></div><div class="KIF"><pre>
KOWLL: (owl#functional_property pm#husband)
       (owl#inverse_functional_property pm#husband)
       (rdfs#domain pm#husband pm#woman)  (rdfs#range pm#husband pm#man)
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;owl:FunctionalProperty rdf:ID="&pm;husband">
         &lt;rdf:type    rdf:resource="&owl;InverseFunctionalProperty" />
         &lt;rdfs:domain rdf:resource="&pm;Woman"/>
         &lt;rdfs:range  rdf:resource="&pm;Man"/> &lt;/owl:FunctionalProperty>
</pre></div><div class="N3"><pre>
N3:    @prefix pm: &lt;"pm#">.  //such namespace declarations will not be repeated in the next N3 examples
       @prefix dolce: &lt;"dolce#">.
       @prefix kif: &lt;"http://logic.stanford.edu/kif/kif.html#">.
       @prefix rdf: &lt;"http://www.w3.org/1999/02/22-rdf-syntax-ns#">.
       @prefix rdfs: &lt;"http://www.w3.org/TR/1999/PR-rdf-schema-19990303#">.
       @prefix dc: &lt;"http://purl.org/metadata/dublin_core#">.
       @prefix daml: &lt;"http://www.daml.org/2000/10/daml-ont#">.
       @prefix pm: &lt;"http://www.webkb.org/kb/theKB_terms.rdf/pm#">.
       @prefix wn: &lt;"http://www.webkb.org/kb/theKB_terms.rdf/wn#">.
       @prefix owl: &lt;"http://www.w3.org/TR/owl-features#">.
       @prefix : &lt;#>.
       pm:husband a owl:FunctionalProperty, owl:InverseFunctionalProperty;
                  rdfs:domain pm:Woman;   rdfs:range pm:Man.
</pre></div><div class="KRF"><pre>
KRF:   not needed here since UML not extended here
</pre></div>

<!-- kif.ps ("definitions" p24 and 57)  let's say that:
- rels from a rel are definitions unless contextualized in time or space
- the < ^ = ~ rels are definitions unless contextualized in time or space
- the rels with "def" as first author are definitions
- all other rels are "any" 
structural_spec__non-logical_spec (?) > positive_context _spec ;   semantic_spec__logical_spec (spec)

     dl#perdurant__occurence__PD
       dl#happens_at=> dl#time_interval ,           //in OWL: this rel. has allValuesFrom this dest.
       dl#has_quality: 1..* dl#Temporal_location ,  //in OWL: this rel. has someValuesFrom this dest.

                     : dl#time_interval (any->0..*)  //by def or not
                     : dl#Temporal_location (any->1..*)
  any quadrilatere necessarily has many dots:      quadrilatere part: side (any->many)
  any quadrilatere can only have for part q-stuff: quadrilatere part: q-stuff (any=>0..*)
  any quadrilatere necessarily has 4 sides:        quadrilatere part: side (def, any->4)
  any quadrilatere happens to be colored here:     quadrilatere attr: color (any->1, location: here)
  any quadrilatere can have for side only a side:  quadrilatere side: side (any->0..1)
  any quadrilatere is a flat_stuff with 4 sides:   quadrilatere = [flat_stuff, part: 4 sides](def)
  any quadrilatere necessarily is a flat_stuff :   quadrilatere < flat_stuff (def)
  any quadrilatere happens to be a colored stuff : quadrilatere < colored_stuff (location: here)

  any morning_star is necessarily the first ... 
  all morning_star happens to be bright
  any man can/may/necesarily have 0..1 wife, can/may/necesarily be agent of 0..1 sleep
  by def of husband, if

1) NUMBER OF SUCH REL FROM THIS CLASS:
FunctionalProperty == all instances are any->0..1  (i.e., is shorthand for stating that the property's cardinality is 0..1) For example, hasPrimaryEmployer may be stated to be a FunctionalProperty. 
Secu-Social-ID is functional, and inverse functional (or unambiguous, i.e, 2 same ID => same person).
Cardinality is stated on a property with respect to a particular (source) class.
 minCardinality: This restriction is another way of saying that the property is required to have a (minimal number of) values for EACH instance of the class. 

2) local restrictions of DEST TYPE FOR SUCH REL FROM THIS CLASS:
allValuesFrom == any=>0..*  The restriction allValuesFrom is stated on a property with respect to a class. It means that this property on this particular class has a LOCAL RANGE RESTRICTION associated with it. This means that if an individual person Louise is related by the property hasDaughter to the individual Deborah, then from this a reasoner can deduce that Deborah is an instance of the class Woman. This restriction allows the property hasDaughter to be used with other classes, such as the class Cat, and have an appropriate value restriction associated with the use of the property on that class.
someValuesFrom == any->1..* since the dest is always given in FL
The restriction someValuesFrom is stated on a property with respect to a class. A particular class may have a restriction on a property that at least one value for that property is of a certain type.  Example: for each wine, at least one maker that is a winery.

3) OTHERS   hasValue and oneOf have indiv for destinations
unionOf, complementOf, and intersectionOf  disjoint=subtypeOfComplement
 OWL Lite, cardinalities are restricted to at least, at most or exactly 1 or 0,
-->


<p><br><div class="E"><pre>
E:     Relations of type pm#parent are from pm#animal to pm#animal. The domain
       cardinality is 0..* and the range cardinality 2..2 (in our real world).
</pre></div><div class="FL"><pre>
FL:    pm#parent (0..* pm#animal, 2 pm#animal);  //0..* is optional here
FL:    pm#animal  pm#parent: pm#animal (any->2, 0..*<-any); //"0..*<-any" is optional
</pre></div><div class="KIF"><pre>
KIF:   (defrelation pm#parent (?x ?y) :=> (and (pm#animal ?x) (pm#animal ?y)))
       (forall ((a pm#animal)) (existsN ('?p pm#animal (pm#parent '?a ?p))))
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;owl:ObjectProperty rdf:ID="&pm;parent">
         &lt;rdfs:domain rdf:resource="&pm;Animal"/>
         &lt;rdfs:range  rdf:resource="&pm;Animal"/> &lt;/owl:ObjectProperty>
       &lt;owl:Class rdf:about="&pm;Animal"/>
         &lt;rdfs:subClassOf>&lt;owl:Restriction>
           &lt;owl:onProperty rdf:resource="&pm;parent"/>
           &lt;owl:cardinality rdf:datatype="&xsd;nonNegativeInteger">2
           &lt;/owl:cardinality> &lt;/owl:Restriction> &lt;/rdfs:subClassOf> &lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    pm:parent a owl:ObjectProperty;  rdfs:domain pm:Animal;  rdfs:range pm:Animal. 
       pm:Animal rdfs:subClassOf
                   [a owl:Restriction;  owl:onProperty pm:Parent;  owl:cardinality 2].
</pre></div>

<div class="UML"><p>Related simple examples in UML:<br>
<center><table border="1" cellspacing=0 cellpadding=5>
           <tr><td><img src="umlAssociation.jpg"></td></tr></table><br>
   <i>An "object property" shown as an association
   <small>(excerpt from <a href="http://hcs.science.uva.nl/usr/Schreiber/docs/owl-uml/owl-uml.html">Schreiber's OWL translation in UML</a>)</small></i></center>

<p><center><table border="1" cellspacing=0 cellpadding=5>
           <tr><td><img src="umlAttribute.jpg"></td></tr></table><br>
   <i>Some "datatype properties" shown as attributes
   <small>(excerpt from <a href="http://hcs.science.uva.nl/usr/Schreiber/docs/owl-uml/owl-uml.html">Schreiber's OWL translation in UML</a>)</small></i></center></div>








<h4><br><br><a name="spec"></a>InstanceOf, SubtypeOf and Subtype Partition</h4>

<p><b>Instance</b> relations can be used between an individual and a class, or
between classes as in the next example.<br>
<div class="E"><pre>
E:     According to OWL, owl#annotation_property has for instance rdfs#label.
</pre></div><div class="FL"><pre>
FL:    owl#annotation_property instance: rdfs#label;  //':' can be used instead of "instance:"
</pre></div><div class="FCG"><pre>
FCG:   [owl#annotation_property, rdf#type of: rdfs#label](owl);
</pre></div><div class="KIF"><pre>
KIF:   (dc#Creator '(owl#annotation_property rdfs#label) owl)
KOWLL: (dc#Creator '(rdf#type rdfs#label owl#annotation_property) owl)
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;rdf:Property rdf:about="&rdfs;label">
         &lt;rdf:type rdf:resource="&owl;AnnotationProperty" dc:Creator="owl"/>
       &lt;/rdf:Property>
</pre></div><div class="N3"><pre>
N3:    {rdfs:label rdf:type owl:AnnotationProperty} dc:Creator "owl".
</pre></div><!--UML:   //image of an instanceOf association with creator-->

<div class="UML"><p>Related simple example in UML:<br>
<center><table border="1" cellspacing=0 cellpadding=5>
           <tr><td><img src="umlTransitive.jpg"></td></tr></table><br>
   <i>Example of how an instanceOf relation and a transitive relation
      may be represented in UML<br>
      <small>(excerpt from <a href="http://hcs.science.uva.nl/usr/Schreiber/docs/owl-uml/owl-uml.html">Schreiber's OWL translation in UML</a>)</small></i></center></div>

<p>Here is an example for <b>subtype</b> relations.
<div class="E"><pre>
E:     According to OWL, owl#datatype_property is a subclass of rdf#property.
</pre></div><div class="FL"><pre>
FL:    owl#datatype_property supertype: rdf#property; //"subtype of" could also be used
FL:    owl#datatype_property < rdf#property; //'<' is a shortcut for "supertype:"
</pre></div><div class="FCG"><pre>
FCG:   [owl#datatype_property, rdfs#sub_class_of: rdf#property](owl);
</pre></div><div class="KIF"><pre>
KIF:   (dc#Creator '(forall ((?i owl#datatype_property)) (rdf#property ?i)) owl)
KOWLL: (dc#Creator '(rdfs#sub_class_of owl#datatype_property rdf#property) owl)
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;owl:Class rdf:about="&owl;DatatypeProperty">
         &lt;rdfs:subClassOf rdf:resource="&rdf;Property" dc:Creator="owl"/>&lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    {owl:DatatypeProperty rdfs:subClassOf rdf:Property} dc:Creator "owl".
</pre></div><!--UML:   //image of a subclass association with creator-->

<p>OWL requires the use of <code>rdfs#sub_property_of</code> instead of 
<code>rdfs#sub_class_of</code> for subtype relations between class of relations.
<p><center><table border="1" cellspacing=0 cellpadding=5>
           <tr><td><img src="umlSubproperty.jpg"></td></tr></table><br>
   <i>Example of the use of a class of relation (property) specializing
      another one<br>
      <small>(excerpt from <a href="http://hcs.science.uva.nl/usr/Schreiber/docs/owl-uml/owl-uml.html">Schreiber's OWL translation in UML</a>)</small></i></center>


<p><br>Here is an example of <b>open subclass partition</b>, that is, a set of 
exclusive subclasses. For each notation except FL and UML, the statement of the
previous example is taken into account, that is, not repeated.
<div class="E"><pre>
E:     According to OWL Lite, owl#datatype_property and owl#object_property are
       exclusive subclasses of rdf#property.
</pre></div><div class="FL"><pre>
FL:    rdf#property > { owl#datatype_property (owl)
                        owl#object_property (owl)   } (owl_lite, exclusive);
        //"{...}" refer to an AND-SET, hence here a list of exclusive subtypes
        //since '>' is a shortcut for "subtype:" and the fact that the members
        //of this set are exclusive is indicated in the context of this set
</pre></div><div class="FCG"><pre>
FCG:   [owl#object_property, rdfs#sub_class_of: rdf#property](owl);
       [owl#object_property, owl#disjoint_with: owl#datatype_property](owl_lite);
</pre></div><div class="KIF"><pre>
KOWLL: (dc#Creator '(rdfs#sub_class_of owl#object_property rdf#property) owl_lite)
       (dc#Creator '(owl#disjoint_with owl#object_property owl#datatype_property)
                   owl_lite)
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;owl:Class rdf:about="&owl;ObjectProperty">
         &lt;rdfs:subClassOf rdf:resource="&rdf;Property" dc:Creator="owl_lite"/>
         &lt;owl:disjointWith rdf:resource="&rdf;DatatypeProperty" dc:Creator="owl_lite"/>
       &lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    {owl:ObjectProperty rdfs:subClassOf rdf:Property} dc:Creator "owl_lite".
       {owl:ObjectProperty owl:disjointWith rdf:DatatypeProperty} dc:Creator "owl_lite".
</pre></div><!--UML:   //image of an open subclass partition with creator-->

<p><br>Here is the same example but with a <b>closed (i.e., complete) subclass 
partition</b>, i.e., a set of exclusive subclasses that covers all the possible 
instances of the source class. (Note: the exclusion between 
<code>owl#datatype_property</code> and <code>owl#object_property</code> exists in
OWL Lite but not anymore in OWL DL/Full). For each notation except FL and UML,
the statements of the two previous examples are taken into account.
<div class="E"><pre>
E:     According to OWL Lite, owl#datatype_property and owl#object_property form
       a complete subclass partition of rdf#property.
</pre></div><div class="FL"><pre>
FL:    rdf#property > {( owl#datatype_property (owl_lite)
                         owl#object_property   (owl_lite) )} (owl_lite, exclusive);
        //"{(...)}" refer to a complete AND-SET, hence here a complete "subtype partition"
</pre></div><div class="FCG"><pre>
FCG:   [rdf#property, owl#union_of: {owl#datatype_property,owl#object_property}(exclusive)
       ](owl_lite);
</pre></div><div class="KIF"><pre>
KOWLL: (dc#Creator '(owl#union_of rdf#property 
                          (listof owl#datatype_property owl#object_property)
                    ) owl_lite)
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;owl:Class rdf:about="&owl;Property"> 
          &lt;owl:unionOf rdf:parseType="Collection" dc:Creator="owl_lite" > 
             &lt;owl:Class rdf:about="&owl;ObjectProperty"/> 
             &lt;owl:Class rdf:about="&owl;DatatypeProperty"/>
          &lt;/owl:unionOf> 
       &lt;/owl:Class> 
       &lt;owl:Class rdf:about="&owl;ObjectProperty"> 
          &lt;owl:disjointWith rdf:resource="&owl;DatatypeProperty" dc:Creator="owl_lite"/>
       &lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    {owl:Property owl:unionOf owl:ObjectProperty,owl:DatatypeProperty} dc:Creator "owl_lite".
       {owl:ObjectProperty owl:disjointWith owl:DatatypeProperty} dc:Creator "owl_lite".
</pre></div><!--UML:   //image of a complete subclass partition with creator-->



<h4><br><br><a name="nonBinary"></a>Non-binary relations</h4>

<p>FL, FCG and KIF accept N-ary relations. One way to translate a non-binary
relation type into OWL is to convert it into a regular class and introduce a
relation for each argument.   <!--    @@@@@@@@@@@@@@@@@@@@@@@@@????? -->
<pre>
</pre><div class="FL"><pre>
FL:    pm#ternary_relation (owl#thing,owl#thing,owl#thing);
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;owl:Class rdf:ID="&pm;TernaryRelation">
         &lt;rdf:Property rdf:ID="&pm;ternaryRelationArg1">
           &lt;rdfs:domain rdf:resource="&owl;thing"/> &lt;/rdf:Property>
         &lt;rdf:Property rdf:ID="&pm;ternaryRelationArg2">
           &lt;rdfs:domain rdf:resource="&owl;thing"/> &lt;/rdf:Property>
         &lt;rdf:Property rdf:ID="&pm;ternaryRelationArg3">
           &lt;rdfs:domain rdf:resource="&owl;thing"/> &lt;/rdf:Property>
       &lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    pm:TernaryRelation a owl:Class;
                          pm:ternaryRelationArg1 owl:thing;
                          pm:ternaryRelationArg2 owl:thing;
                          pm:ternaryRelationArg3 owl:thing.
</pre></div>


<h4><br><br><a name="declExample"></a>Synthesis: a typical example</h4>

<pre>
</pre><div class="FL"><pre>
FL:    pm#thing__something (^any object is instance of this class^) 29/11/1999
         name:  "chose" (kr, language: wn#French),  instance of:  owl#class,
         >  {(pm#situation pm#entity)}(exclusive)  pm#thing_playing_some_role,
         =  owl#thing suo#entity;
</pre></div><div class="KIF"><pre>
KOWLL: (owl#class pm#thing)
         (rdfs#label pm#thing "something") //the binary relation rdfs#label
         (dc#Creator '(xml#lang '(rdfs#label pm#thing "chose") fr) kr)
         (dc#Creator pm#thing pmartin@dstc.edu.au) 
         (dc#Date pm#thing "29/11/1999")
         (rdfs#comment pm#thing "any object is instance of this class")
         (owl#union_of pm#thing (listof pm#situation pm#entity))
         (owl#disjointWith pm#entity pm#situation)
         (rdfs#subClassOf pm#entity pm#thing)
         (rdfs#subClassOf pm#situation pm#thing)
         (rdfs#subClassOf pm#thing_playing_some_role pm#thing)
         (owl#sameClassAs pm#thing owl#thing)    (owl#sameClassAs pm#thing suo#entity)
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;owl:Class rdf:ID="&pm;Thing">
         &lt;rdfs:label>thing&lt;/rdfs:label> &lt;rdfs:label>something&lt;/rdfs:label>
         &lt;rdfs:label xml:lang="fr" dc:Creator="kerry@dstc.edu.au">chose&lt;/rdfs:label>
         &lt;dc:Creator>pmartin@dstc.edu.au&lt;/dc:Creator>
         &lt;dc:Date>29/11/1999&lt;/dc:Date>
         &lt;rdfs:comment>any object is instance of this class&lt;/rdfs:comment>
         &lt;owl:unionOf rdf:parseType="Collection">
           &lt;owl:Class rdf:ID="&pm;Entity"/>
           &lt;owl:Class rdf:ID="&pm;Situation"/> &lt;/owl:unionOf>
         &lt;owl#sameClassAs rdf:resource="&owl;Thing"/>
         &lt;owl#sameClassAs rdf:resource="&suo;Entity"/>
       &lt;/owl:Class>
       &lt;owl:Class rdf:about="&pm;Entity">
         &lt;owl:disjointWith rdf:about="&pm;Situation"/> &lt;/owl:Class>
       &lt;owl:Class rdf:about="&pm;ThingPlayingSomeRole">
         &lt;rdfs:subClassOf rdf:about="&pm;Thing"/> &lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    pm:Thing a owl:Class;
          rdfs:label "thing", "something";  dc:Creator pmartin@dstc.edu.au;
          dc:Date "29/11/1999";  rdfs:comment "any object is instance of this class";
          owl:unionOf (pm:Entity  pm:Situation);  owl:sameClass owl:Thing, suo:Entity.
       {{pm:Thing rdfs:label "chose"} xml:lang "fr"} dc:Creator "kerry@dstc.edu.au".
       pm:Entity a owl:Class;  owl:disjointWith pm:Situation.
       pm:ThingPlayingSomeRole a owl:Class;  rdfs:subClassOf pm:Thing.
</pre></div>

<h4><br><br><a name="shortcut"></a>Relations-From/To-a-Class Used As Shortcuts</h4>

<p>Lexical ontologies such as WordNet often have additional
relations-from/to-a-class that are of a different nature than the above cited 
ones: they are simply shortcuts for universally quantified assertions.
Examples of such relations are <code>memberOf</code>, <code>substanceOf</code>,
<code>partOf</code>, <code>locationOf</code> and <code>urlOf</code>.

<p>In FL, the relation "partOf" refers to the spatial/physical "partOf"
(i.e., "portionOf" or "componentOf") when spatial entities are connected,
and "subprocessOf" when processes are connected. The relation "part" refers to
"part", the inverse of "partOf".
<!-- obsolete:
  As the following example shows, the
universal quantifier is on the source of the "part" relation (or the destination
of the "P" relation). The same convention applies for similar relations, e.g.,
"m" ("member"), "s" ("substance"), "l" ("location") and "u" ("url").
-->
<!-- For all transitive relations, partitioning may -->
The example also shows how cardinality and complete/open partitions for 
transitive relations may be specified. The relation type
<code>pm#disjoint_part</code> is defined in the KIF version and re-used in the
OWL version.
<div class="E"><pre>
E:     Any human body has at most 2 arms. Any arm belongs to at most 1 body.
</pre></div><div class="FL"><pre>
FL:    pm#human_body part: wn#arm (any->0..2, 0..1<-any);
</pre></div><div class="KIF"><pre>
KIF:   (forall ((?b pm#human_body)) (atMostN 2 '?a wn#arm (pm#part ?b '?a)))
       (forall ((?a wn#arm)) (atMostN 1 '?b pm#human_body (pm#part '?b ?a)))
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;rdf:Property rdf:ID="ArmPart">&lt;rdfs:subPropertyOf rdf:resource="&pm;part"/>
         &lt;owl:inverseOf rdf:ID="ArmPartOf"/>
         &lt;rdfs:range rdf:resource="&wn;Arm"/> &lt;/rdf:Property>
       &lt;owl:Class rdf:about="&pm;HumanBody">&lt;rdfs:subClassOf>
         &lt;owl:Restriction>&lt;owl:onProperty rdf:resource="#ArmPart"/>
           &lt;owl:maxCardinality rdf:datatype="&xsd;nonNegativeInteger">2
           &lt;/owl:maxCardinality>&lt;/owl:Restriction> &lt;/rdfs:subClassOf>&lt;/owl:Class>
       &lt;owl:Class rdf:about="&wn;Arm">&lt;rdfs:subClassOf>
         &lt;owl:Restriction>&lt;owl:onProperty rdf:resource="#ArmPartOf"/>
           &lt;owl:maxCardinality rdf:datatype="&xsd;nonNegativeInteger">1
           &lt;/owl:maxCardinality>&lt;/owl:Restriction> &lt;/rdfs:subClassOf>&lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    :ArmPart a rdf:Property;             rdfs:subPropertyOf pm:part;
                owl:inverseOf :ArmPartOf;   rdfs:range wn:Arm.
       pm:HumanBody rdfs:subClassOf
          [a owl:Restriction;  owl:onProperty ArmPart;  owl:cardinality 2]. 
       wn:Arm rdfs:subClassOf
          [a owl:Restriction;  owl:onProperty ArmPartOf;  owl:cardinality 1].
</pre></div>


<!-- <div class="E"><pre>
E:     Any human being has 1 body, and each body belongs to only 1 human being.
       Any human body can be fully decomposed into 1 upper_body and 0 or 1 
       lower body.  An upper or lower body belong to only 1 human body.
</pre></div><div class="FL"><pre>
FL:    pm#body part of: #human (any->1, 1<-any),
               part: {( pm#upper_body (any->1,1<-any)  pm#lower_body (any->1,0..1<-any) 
                     )}(exclusive);
        //"{(...)}" refer to a complete AND-SET, hence here a complete "part partition"
</pre></div><div class="KIF"><pre>
KIF:   (forall ((?h pm#human))      (exists1 '?b pm#body       (pm#part ?h '?b)))
       (forall ((?b pm#body))       (exists1 '?h pm#human      (pm#part '?h ?b)))
       (forall ((?b pm#body))       (exists1 '?u pm#upper_body (pm#part ?b '?u)))
       (forall ((?b pm#body))    (exists0or1 '?l pm#lower_body (pm#part ?b '?l)))
       (forall ((?u pm#upper_body)) (exists1 '?b pm#body       (pm#part '?b ?u)))
       (forall ((?l pm#lower_body)) (exists1 '?b pm#body       (pm#part '?b ?l)))
       (pm#disjoint_part pm#upper_body pm#lower_body)
</pre></div><div class="XOWL"><pre>
XOWLL: //6 relations must be introduced for defining cardinalities.
       //     Because these relations are so artificial, "has" or "is" is
       //     used at the beginning of their key names.
       &lt;rdf:Property rdf:ID="hasBodyAsPart">
         &lt;rdfs:subPropertyOf rdf:resource="&pm;part"/>
         &lt;owl:inverseOf rdf:ID="&pm;isPartOfHuman"/>
         &lt;rdfs:range rdf:resource="&pm;Body"/> &lt;/rdf:Property>
       &lt;rdf:Property rdf:ID="hasUpperBodyAsPart">
         &lt;rdfs:subPropertyOf rdf:resource="&pm;part"/>
         &lt;owl:inverseOf rdf:ID="&pm;isUpperPartOfBody"/>
         &lt;rdfs:range rdf:resource="&pm;UpperBody"/> &lt;/rdf:Property>
       &lt;rdf:Property rdf:ID="hasLowerBodyAsPart">
         &lt;rdfs:subPropertyOf rdf:resource="&pm;part"/>
         &lt;owl:inverseOf rdf:ID="&pm;isLowerPartOfBody"/>
         &lt;rdfs:range rdf:resource="&pm;LowerBody"/> &lt;/rdf:Property>

       &lt;owl:Class rdf:about="&pm;Human">&lt;rdfs:subClassOf>
           &lt;owl:Restriction>&lt;owl:onProperty rdf:resource="#hasBodyAsPart"/>
             &lt;owl:cardinality rdf:datatype="&xsd;nonNegativeInteger">1
             &lt;/owl:cardinality>&lt;/owl:Restriction>&lt;/rdfs:subClassOf>&lt;/owl:Class>
       &lt;owl:Class rdf:about="&pm;Body">
         &lt;owl:intersectionOf rdf:parseType="Collection">
           &lt;owl:Restriction>&lt;owl:onProperty rdf:resource="#isPartOfHuman"/>
             &lt;owl:cardinality rdf:datatype="&xsd;nonNegativeInteger">1
             &lt;/owl:cardinality> &lt;/owl:Restriction>
           &lt;owl:Restriction>&lt;owl:onProperty rdf:resource="#hasUpperBodyAsPart"/>
             &lt;owl:cardinality rdf:datatype="&xsd;nonNegativeInteger">1
             &lt;/owl:cardinality> &lt;/owl:Restriction>
           &lt;owl:Restriction>&lt;owl:onProperty rdf:resource="#hasLowerBodyAsPart"/>
             &lt;owl:maxCardinality rdf:datatype="&xsd;nonNegativeInteger">1
             &lt;/owl:cardinality> &lt;/owl:Restriction>
         &lt;/owl:intersectionOf>&lt;/owl:Class>
       &lt;owl:Class rdf:about="&pm;LowerBody">&lt;rdfs:subClassOf>
           &lt;owl:Restriction>&lt;owl:onProperty rdf:resource="#isUpperPartOfBody"/>
             &lt;owl:cardinality rdf:datatype="&xsd;nonNegativeInteger">1
             &lt;/owl:cardinality>&lt;/owl:Restriction>&lt;/rdfs:subClassOf>&lt;/owl:Class>
       &lt;owl:Class rdf:about="&pm;LowerBody">&lt;rdfs:subClassOf>
           &lt;owl:Restriction>&lt;owl:onProperty rdf:resource="#isLowerPartOfBody"/>
             &lt;owl:cardinality rdf:datatype="&xsd;nonNegativeInteger">1
             &lt;/owl:cardinality>&lt;/owl:Restriction>&lt;/rdfs:subClassOf>&lt;/owl:Class>
       &lt;owl:Class rdf:about="&pm;UpperBody">
         &lt;pm:disjointPart rdf:about="&pm;LowerBody"/> &lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    :hasBodyAsPart a rdf:Property;  rdfs:subPropertyOf pm:part;
                      owl:inverseOf pm:isPartOfHuman;  rdfs:range pm:Body.
       :hasUpperBodyAsPart a rdf:Property;  rdfs:subPropertyOf pm:part;
                           owl:inverseOf pm:isUpperPartOfBody;  rdfs:range pm:UpperBody.
       :hasLowerBodyAsPar a rdf:Property;  rdfs:subPropertyOf pm:part;
                           owl:inverseOf pm:isLowerPartOfBody;  rdfs:range pm:LowerBody.
       pm:Human rdfs:subClassOf
          [a owl:Restriction;  owl:onProperty :hasBodyPart;  owl:cardinality 1]. 
       pm:Body rdfs:subClassOf
          [a owl:Restriction;  owl:onProperty :isPartOfHuman;  owl:cardinality 1],
          [a owl:Restriction;  owl:onProperty :hasUpperBodyAsPart;  owl:cardinality 1],
          [a owl:Restriction;  owl:onProperty :hasLowerBodyAsPart;  owl:cardinality 1].
       pm:LowerBody rdfs:subClassOf
          [a owl:Restriction;  owl:onProperty :isUpperPartOfBody;  owl:cardinality 1]. 
       pm:LowerBody rdfs:subClassOf
          [a owl:Restriction;  owl:onProperty :isLowerPartOfBody;  owl:cardinality 1]. 
       pm:UpperBody pm:disjointPart pm:LowerBody.
</pre></div>
<p>Here are KIF definitions for <code>exists1</code>, <code>exists0or1</code>
and <code>pm#disjoint_part</code>:<pre>
(defrelation exists0or1 (?var ?predicate) :=
  (truth ^(or (not (exists (,?var) (,?predicate ,?var)))
              (exists1 (,?var) (,?predicate ,?var)))))

(defrelation pm#disjoint_part (?x ?y)
  (truth ^(and (/= ,?x ,?y)
               (not (exists (?z) (and (pm#part ,?x ?z) (pm#part ,?y ?z)))))))
</pre>

<div class="E"><pre>
E:     Any human being has 1 body. Any human body belongs to only 1 human being.
       Any human body has at most 2 arms. Any arm belongs to only 1 body.
</pre></div><div class="FL"><pre>
FL:    pm#human_body part of: wn#human (any->1, 1<-any), part: wn#arm (any->1, 0..2<-any);
</pre></div><div class="KIF"><pre>
KIF:   (forall ((?h pm#human)) (exists1 '?b pm#human_body (pm#part ?h '?b)))
       (forall ((?b pm#human_body)) (exists1 '?h pm#human (pm#part '?h ?b)))
       (forall ((?b pm#human_body)) (atMostN 2 '?a wn#arm (pm#part ?b '?a)))
       (forall ((?a wn#arm))   (exists1 '?b pm#human_body (pm#part '?b ?a)))

(defrelation exists1 (?var ?type ?predicate) :=
  (truth ^(exists (,?var)
    (and (,?type ,?var) (,?predicate ,?var)
         (forall(?y) (=> (,?predicate ?y) (= ,?var ?y)))))))

(defrelation existsN (?op ?num ?var ?type ?predicate) :=
  (exists ((?s set)(?n)) (and (size ?s ?n) (?op ?n ?num)
    (truth ^(forall (,?var) (=> (member ,?var ,?s)
                                (and (,?type ,?var) ,?predicate)))))))

(defrelation exactlyN (?num ?var ?type ?predicate) :=
  (exists ((?s set)) (and (size ?s ?num)
    (truth ^(forall (,?var) (=> (member ,?var ,?s)
                                (and (,?type ,?var) ,?predicate)))))))
</pre></div> -->

<p>Here is a KIF definition of <code>atMostN</code>:
<pre>
(defrelation atMostN (?num ?var ?type ?predicate) :=
  (exists ((?s set)(?n)) (and (size ?s ?n) (=< ?n ?num)
    (truth ^(forall (,?var) (=> (member ,?var ,?s)
                                (and (,?type ,?var) ,?predicate)))))))
</pre>

<p><br><br><a name="lambda"></a><h3>Lambda Abstractions, Qualitative Valuation</h3>

<p>A lambda abstraction is an on-the-fly (i.e., in the middle of a statement,
instead of using a class name) complete definition of an anonymous class (i.e.,
unnamed and therefore not stored in the ontology). Its use is very handy with
universal quantifiers (or similar extended quantifiers) as the following example 
shows. The example also shows that in KIF and OWL, a class named "healthy_bird"
had to be explicitely introduced instead of being kept anonymous.
(However, OWL permits some restricted kinds of lambda-abstractions via the use of
<code>owl#restriction</code>).

<p>The example also illustrates another kind of shortcut in FE and FCG:
the use of the keyword "good" (which is one of the few predefined keywords for
qualitative valuation in FE and FCG) instead of the use of a "measure" relation.
<div class="E"><pre>
E:     At least 93% of healthy birds fly.
</pre></div><div class="FE"><pre>
FE:    At least 93% of [bird experiencer of a good health] are agent of a flight.
</pre></div><div class="FCG"><pre>
FCG:   [at least 93% of (bird,experiencer of:a good health), agent of: a flight]
</pre></div><div class="KIF"><pre>
KIF:   (defobject healthy_bird (?b) :=
         (exists ((?h health))
           (and (bird ?b) (experiencer ?h ?b) (measure ?h good))))
       (forAtLeastNpercent 93 '?x healthy_bird
         (exists ((?f flight)) (agent ?f '?x)))
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;owl:Class rdf:ID="GoodHealth">
         &lt;owl:intersectionOf rdf:parseType="Collection">
            &lt;owl:Class rdf:about="#Health"/>
            &lt;owl:Restriction>&lt;owl:onProperty rdf:resource="#measure"/>
              &lt;owl:hasValue rdf:resource="#Good"/>&lt;/owl:Restriction>
         &lt;/owl:intersectionOf>&lt;/owl:Class>
       &lt;owl:Class rdf:ID="HealthyBird">
         &lt;owl:equivalentClass>&lt;owl:Restriction>
           &lt;owl:onProperty rdf:resource="#experiencerOf"/>
           &lt;owl:allValuesFrom rdf:resource="#GoodHealth"/>&lt;/owl:Restriction>
         &lt;/owl:equivalentClass>&lt;/owl:Class>
       &lt;owl:Class rdf:about="#HealthyBird" quantifier="at least 93%">
         &lt;agentOf>&lt;Flight/>&lt;/agentOf>&lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    :GoodHealth owl:intersectionf :Health,
          [a owl:Restriction;  owl:onProperty :measure;  owl:hasValue :Good]. 
       :HealthyBird owl:equivalentClass
          [a owl:Restriction;  owl:onProperty :exprerienceOf;  owl:allValuesFrom :GoodHealth]. 
       {:HealthyBird :agentOf :Flight} :quantifier "at least 93%".
</pre></div><div class="KRF"><pre>
KRF:   LNode { embeddedNode1: QNode {cType:bird
                    quantifier: Quantifier{kind:percentage num:"93"}
                    sourceOf: isReversed Relation {rType:experiencer
                                dest: QNode {cType: health  qualifier:good}}}
               sourceOf: Relation {rType:agent dest: QNode {cType: flight}} }
</pre></div>













<p><br><br><a name="numerical"></a><h2>6. Numerical Quantification</h2>

<p>Besides the classic quantifiers "there exists" and "for any", extended
quantifiers such as "at least 2", "60%" or "most" are also very useful.
As shown below, there is no problem to define them in KIF.<br>
In OWL, as shown in the previous example, cardinalities may sometimes be used
to represent simple numerical quantifiers (this only works within class
definitions; it would not work for example to represent "Tom has only 
3&nbsp;legs"). For other cases, there are two solutions:
(i)&nbsp;using an approach similar to the one used for the KIF statements, 
which would involve the use of <code>owl#one_of</code> relations (to define/get
a list for the instances of a class), <code>kif#length</code> relations (to
define/get the number of elements in a list), and mutiplication and comparison
relations, or
(ii)&nbsp;define a class attribute "<code>quantifier</code>".
Both approaches are ad-hoc, may be difficult to use for specifying the scope of
quantifiers in complex statements, and no OWL inference engine will be able to
use them since they involve elements outside OWL. Here, the latter approach is
adopted because it is much simpler to use by people and (adapted) inference
engines.<br>
In FCG and FE, the quantifier "most" means "at least 60%". A similar equivalence
for OWL statements could be adopted by the W3C.

<p>The following example also shows how "physical possibility" may be
represented using the keyword "can" in FE and FCG, or contexts in KIF and OWL.
However, (i)&nbsp;unless identifiers for "modality" and "physical_possibility" are
standardized, no inference engine will use them, (ii)&nbsp;specifying a context
over a class definition may not be accepted or understood by OWL inference
engines, (iii)&nbsp;specifying the scope of contexts in OWL may be problematic for
complex statements.
<div class="E"><pre>
E:     At least 85% of birds are able to fly.
</pre></div><div class="FE"><pre>
FE:    At least 85% of bird can be agent of a flight.
</pre></div><div class="FCG"><pre>
FCG:   [at least 85% of bird, can be agent of: a flight]
</pre></div><div class="KIF"><pre>
KIF:   (forAtLeastNpercent 85 '?x bird
         (exists ((?f flight)) (modality '(agent ?f ,?x) physical_possibility)))
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;rdf:Property rdf:ID="quantifier">
         &lt;rdfs:domain rdf:resource="&owl;Class"/>
         &lt;rdfs:range rdf:resource="&rdfs;Literal"/> &lt;/rdf:Property>
       &lt;owl:Class rdf:about="#Bird" rdf:bagID="b" quantifier="at least 85%">
         &lt;agentOf>&lt;Flight/>&lt;/agentOf>&lt;/owl:Class>
       &lt;rdf:Description rdf:aboutEach="#b">
         &lt;modality rdf#resource="#PhysicalPossibility"/> &lt;/rdf:Description>
</pre></div><div class="N3"><pre>
N3:    :quantifier a rdf:Property;  rdfs:domain owl:Class;  rdfs:range  rdfs:Literal.
       :Bird rdf:bagID :b;  quantifier "at least 85%".
       @forAll :b . { {:b :agentOf :Flight} :modality :PhysicalPossibility }.
</pre></div><div class="KRF"><pre>
KRF:   QNode {cType:bird quantifier:Quantifier{kind:percentage num:"85"}
              sourceOf: Relation {rType:agent  modality:"can"
                  dest: QNode {cType: flight} }}
</pre></div>
<p>Introduced constructs:
<pre>
&lt;rdf:Property rdf:ID="quantifier">
  &lt;!-- domain: either a class or a description that uses aboutEach -->
  &lt;rdfs:range rdf:resource="&rdfs;Literal"/> &lt;/rdf:Property>

(defrelation forAtLeastNpercent (?n ?var ?type ?predicate) :=
  (exists ((?s set))
    (and (truth ^(forall (,?var) (=> (member ,?var ,?s) (,?type ,?var)))
         (>= (numMembersSuchThat ,?s ,?predicate) (/ (* (size ,?s) ?n) 100)))))

  (define-function numMembersSuchThat (?set ?p) :-> ?num :=
    (if (and (set ?set) (predicate ?p)) (numElemsSuchThat (listOf ?set) ?p)))

  (define-function numElemsSuchThat (?list ?p) :-> ?num :=
    (cond ((null ?list) 0)
          ((list ?list) (if ?p (1+ (numElemsSuchThat (rest ?list) ?p))))))
</pre>

<p><br>The above OWL representation uses <code>agentOf</code>, the relation type
inverse of <code>agent</code>. The RDF/XML syntax is so poor that it
requires the definition of a new type instead of permitting the use of some
syntactic sugar such as a keyword <code>of</code>. It is un-natural
and time-consuming for the user, and also imposes additional work to the 
OWL parser or inference engine.

<!-- <div class="E"><pre>
E:   A study by Dr Foo (identifiable by Foo@bird.org) states that in 1999
     at least 85% of healthy birds are able to fly.
</pre></div><div class="FE"><pre>
FE:  ' ' 'at least 85% of [bird experiencer of: a good health]
           can be agent of a flight' with time 1999'
       has for source a study with author Foo@bird.org.
</pre></div><div class="FCG"><pre>
FCG: [ [ [at least 85% of (bird, experiencer of: a good health),
           can be agent of: a flight], time: 1999],
       source: (a study, author: Foo@bird.org)]
</pre></div><div class="KIF"><pre>
KIF: (exists ((?s study))
       (and (author ?s Foo@bird.org)
            (source ?s '(time 
              '(forAtLeastNpercent 85 '?x healthy_bird
                  (exists ((?f flight))
                    (modality '(agent ?f ,?x) physical_possibility)))
              1999))))
     (defobject healthy_bird (?b) :=
         (exists ((?h health)) (and (bird ?b) (chrc ?b ?h) (measure ?h good))))
OWL: &lt;rdf:Property rdf:ID="quantifier">
       &lt;rdfs:domain rdf:resource="&owl;Class"/>
       &lt;rdfs:range rdf:resource="&rdfs;Literal"/> &lt;/rdf:Property>
     &lt;owl:Class rdf:about="#HealthyBird" rdf:bagID="b" quantifier="at least 85%">
       &lt;agentOf>&lt;Flight/>&lt;/agentOf>&lt;/owl:Class>
     &lt;rdf:Description rdf:bagID="85pcHealthyBirdsCanFly" rdf:aboutEach="#b">
       &lt;modality rdf#resource="#PhysicalPossibility"/> &lt;/rdf:Description>
     &lt;rdf:Description rdf:bagID="85pcHealthyBirdsCanFlyIn1999"
           rdf:aboutEach="#85pcHealthyBirdsCanFly" time="1999"/>
     &lt;rdf:Description rdf:aboutEach="#85pcHealthyBirdsCanFlyIn1999">
       &lt;source rdf#resource="#SomeStudy"/> &lt;/rdf:Description>
     &lt;rdf:Description rdf:ID="SomeStudy">&lt;author>Foo@bird.org&lt;/author> &lt;/rdf:Description>

     &lt;owl:Class rdf:ID="GoodHealth">
       &lt;owl:intersectionOf rdf:parseType="Collection">
          &lt;owl:Class rdf:about="#Health"/>
          &lt;owl:Restriction>&lt;owl:onProperty rdf:resource="#measure"/>
            &lt;owl:hasValue rdf:resource="#Good"/>&lt;/owl:Restriction>
       &lt;/owl:intersectionOf>&lt;/owl:Class>
     &lt;owl:Class rdf:ID="HealthyBird">
       &lt;owl:equivalentClass>&lt;owl:Restriction>
         &lt;owl:onProperty rdf:resource="#chrc"/>
         &lt;owl:allValuesFrom rdf:resource="#GoodHealth"/>&lt;/owl:Restriction>
       &lt;/owl:equivalentClass>&lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:  :quantifier rdfs:domain owl:Class;
                 rdfs:range rdfs:Literal.
     {:HealthyBird :agentOf :Flight} rdf:bagID :b; :quantifier "at least 85%".
     {:b :modality :PhysicalPossibility} rdf:bagID :85pcHealthyBirdsCanFly.
     {:85pcHealthyBirdsCanFly :time 1999} rdf:bagID :85pcHealthyBirdsCanFlyIn1999.
     :85pcHealthyBirdsCanFlyIn1999 :source :SomeStudy.
     :SomeStudy :author Foo@bird.org.

     :GoodHealth a rdf:Property; owl:intersectionOf :Health,
          [a owl:Restriction;  owl:onProperty :measure;  owl:hasValue :Good]. 
     :HealthyBird a rdf:Property; owl:equivalentClass
          [a owl:Restriction;  owl:onProperty :chrc;  owl:allValuesFrom :GoodHealth].
</pre></div> -->





<p><br><br><h2><a name="isolatedCollections"></a>
<h2>7. Alternatives and Isolated Collections</h2>

<p><i>Td be written.</i>


<p><br><br><h2><a name="negations"></a>
<h2>8. Negation, Difference, Exclusion, Complement, Reverse</h2>

<p>Two forms of negation have been presented above: one involving a
<code>different_from</code> relation (<code>differentFrom</code> in
OWL, <code>/=</code> in KIF), and one involving the negation of a sentence
("not" in KIF). This last form is more difficult to exploit
by inference engines and leaves room for ambiguity. For example, "Tom does not
own a blue car" may mean that "Tom has a car but not blue" or that "Tom does not
have a car". Thus, it is better to use the first form, or break sentences into
smaller blocks connected by coreference variables in order to reduce or avoid 
ambiguities.<br>
Here is a variant of the first form: negation on types. In the OWL translation,
it is unclear if a <code>owl#different_from</code> relation is sufficient or
if a <code>owl#complement_of</code> relation is required (in which case 
OWL&nbsp;DL would be necessary).
<div class="E"><pre>
E:     Tom owns something that is not a car.
</pre></div><div class="FE"><pre>
FE:    Tom is owner of a !car.
</pre></div><div class="FCG"><pre>
FCG:   [Tom, owner of: a !car]
</pre></div><div class="KIF"><pre>
KIF:   (exists (?type ?x) (and (owner ?x Tom) (holds ?type ?x) (/= ?type car)))
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;owl:Thing>&lt;owner>&lt;owl:Thing rdf:about="#Tom"/>&lt;/owner>
                  &lt;rdf:type>&lt;owl:Class>&lt;owl:differentFrom rdf:resource="#car"/>
                            &lt;/owl:Class> &lt;/rdf:type> &lt;/owl:Thing>
</pre></div><div class="N3"><pre>
N3:    [a [a owl:Class;   owl:differentFrom :Car];  :owner :Tom].
</pre></div><div class="KRF"><pre>
KRF:   TNode {term:Tom 
         sourceOf: isReversed Relation{rType:owner dest:
           isNegatedType QNode{cType:car}}}
</pre></div>


<p>Exclusion between objects (and hence, some forms of negation between classes,
instances or statements) may also be represented via XOR-collections or
OR-collections.<br>
RDF (and hence OWL) proposes an <code>alt</code> collection to store alternatives
but unfortunately does not specify if this "or" is inclusive or exclusive.
Although specializing <code>alt</code> by <code>or_bag</code> and
<code>xor_set</code> seems a good idea (even if RDF engines are unlikely to take
advantage of this distinction), the current RDF/XML grammar only permits to define
members (using <code>rdf#li</code> relations) to collections of type <code>Bag,
Alt</code> and <code>Seq</code> and <i>not</i> specializations of these types!
Furthermore, it is unclear how collections on types are interpreted in RDF
(distributive, collective or cumulative interpretation).
Hence, it is better to use relations such as <code>owl#union_of</code>,
<code>owl#one_of</code>, <code>owl#disjoint_with</code>,
<code>owl#complement_of</code> or <code>owl#differentFrom</code>).
Here is an example of OR-collection between instances. (Note: <code>red</code>,
<code>yellow</code> and <code>orange</code> are not instance but subtype of
<code>color</code>, and have many subtypes, e.g., <code>crimson, dark_red</code> and
<code>chrome_red</code>. The instances of these colors are the actual occurrences
of colors that physical objects have.)
<div class="E"><pre>
E:     Tom's car is red, yellow or orange.
</pre></div><div class="FE"><pre>
FE:    Tom is owner of a car that has for color OR{a red, a yellow, an orange}.
</pre></div><div class="FCG"><pre>
FCG:   [Tom, owner of: (a car, color: OR{a red, a yellow, an orange})]
</pre></div><div class="KIF"><pre>
KIF:   (exists ((?x car) ?c)
         (and (owner ?x Tom) (color ?x ?c) (or (red ?c)(yellow ?c)(orange ?c))))
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;Car>&lt;owner>&lt;owl:Thing rdf:about="#Tom"/>&lt;/owner>
         &lt;color>&lt;owl:Thing>
                  &lt;rdf:type>&lt;owl:Class>&lt;owl:unionOf rdf:parseType="Collection">
                                         &lt;Red/>&lt;Yellow/>&lt;Orange/>&lt;/owl:unionOf>
                  &lt;/rdf:type>&lt;/owl:Thing>&lt;/color>&lt;/Car>
</pre></div><div class="N3"><pre>
N3:    [a :Car;  :owner :Tom;
                 :color [a [owl:unionOf (:Red :Yellow :Orange)] ].
</pre></div><div class="KRF"><pre>
KRF:   TNode {term:Tom 
         sourceOf:isReversed Relation{rType:owner dest:
           QNode{cType:car sourceOf: Relation{rType:color dest:
             NodeCollection{aggregation:or collElt:QNode{cType:red}
               collElt:QNode{cType:yellow} collElt:QNode{cType:orange}}}}}}
</pre></div>
<p>It should be noted that for this example, using a type such as 
<code>warm_color</code> would have been better than using an OR-collection of
<code>red</code>, <code>yellow</code> and <code>orange</code> (and this would
have eased inferencing). More generally, negation can be represented in numerous
ways and these representations are often difficult for an inference engine to
compare and hence fully exploit. Both for knowledge exchange with frame-based
systems and for knowledge inferencing, <code>different_from</code> relations 
between instances or types should be prefered to other forms of negations.





<h4><br><br><a name="different"></a>Different_from, Exclusion, Complement, Reverse</h4>

<p>In the WebKB-2 model and KRM, objects are assumed to be different when they
are not connected by identity relations. This convention eases both knowledge
entering, storage and inferencing. Because of it, no notation has been given
for <b>different-from</b> relations in FL and KRF. In OWL, the
"unique name" assumption is left as an inference engine choice (which in our
opinion is not a good decision for knowledge representation and sharing purposes)
and hence <code>owl#differentFrom</code> is provided by OWL Lite.
<div class="E"><pre>
E:     According to pm, pm#state is different from dolce#state.
</pre></div><div class="FCG"><pre>
FCG:   [pm#state, != dolce#state](pm);
</pre></div><div class="KIF"><pre>
KIF:   (dc#Creator '(/= pm#state dolce#state) pm)
KOWLL: (dc#Creator '(owl#differentFrom pm#state dolce#state) pm)
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;owl:Class rdf:about="&pm;State">
         &lt;owl:differentFrom rdf:resource="&dolce;State" dc:Creator="pmartin@dstc.edu.au"/>
       &lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    {pm:State owl:differentFrom dolce:State} dc:creator "pmartin@dstc.edu.au".
</pre></div><!--UML:   //image of a different-from association with creator -->

<p><br><b>Exclusion</b> relations are the "relations-from/to-a-class" most
commonly used in ontologies after subtypeOf and instanceOf relations. They are 
often given via the subtype partitions (presented with subtypeOf). An exclusion
relation states that its source and destination cannot have common subtypes nor
instances.
<div class="E"><pre>
E:     According to dolce, dolce#state and dolce#process are exclusive.
</pre></div><div class="FL"><pre>
FL:    dolce#state  exclusion: dolce#process; //the creator of the relation does not need to
        //be specified because it is identical to the creator of the source object;
        //this convention will also be used for OWL translations
FL:    dolce#state ! dolce#process;  //'!' is an abbreviation for "exclusion:"
</pre></div><div class="FCG"><pre>
FCG:   [dolce#state, owl#disjoint_with: dolce#process](dolce);
</pre></div><div class="KIF"><pre>
KOWLD: (dc#Creator '(owl#disjoint_with dolce#state dolce#process) dolce)
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;owl:Class rdf:about="&dolce;State">
         &lt;owl:disjointWith rdf:resource="&dolce;Process" dc:Creator="dolce"/>&lt;/owl:Class>
</pre></div><div class="N3"><pre>
N3:    {dolce:State owl:disjointWith dolce:Process} dc:creator "dolce".
</pre></div><!--UML:   //image of an exclusion association with creator -->

<div class="UML"><p>Related simple example in UML:<br>
<center><table border="1" cellspacing=0 cellpadding=5>
           <tr><td><img src="umlDisjoint.jpg"></td></tr></table><br>
   <i>Example of how exclusive classes may be represented in UML<br>
      <small>(excerpt from <a href="http://hcs.science.uva.nl/usr/Schreiber/docs/owl-uml/owl-uml.html">Schreiber's OWL translation in UML</a>)</small></i></center></div>


<p><br>The destination class of a <b>complementOf</b> relation covers all the 
instances that are not covered by the source class (and conversely). Given this
meaning, apart from connecting the classes <code>owl#thing</code> and
<code>owl#nothing</code>, one may wonder which other named classes this relation
can connect. However, in OWL, this relation is useful within definitions to refer
to the complement of a class and then specialize it or intersect it with another
class. <!--
<div class="E"><pre>
E:     According to pm, owl#different_from is the complement of owl#same_as
       (pm thinks that things may be unknown but not "undecided").
</pre></div><div class="FL"><pre>
FL:    owl#different_from  / owl#same_as (pm);
</pre></div><div class="FCG"><pre>
FCG:   [owl#different_from, owl#complementOf: owl#same_as](dolce);
</pre></div><div class="KIF"><pre>
KOWLD: (dc#Creator '(owl:complementOf owl#different_from owl#same_as) pm)
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;rdf:Property rdf:about="&owl;differentFrom">
         &lt;owl:complementOf rdf:resource="&owl;sameAs" dc:Creator="pmartin@dstc.edu.au"/>
       &lt;/rdf:Property>
</pre></div><div class="N3"><pre>
N3:    {owl:differentFrom  owl:complementOf owl:sameAs } dc:Creator "pmartin@dstc.edu.au".
</pre></div><div class="UML"><pre>        
UML:   //image of a complementOf association with creator
</pre></div> -->

<p><br><b>Inverse</b> relations can only be set between relation typees.
<div class="E"><pre>
E:     According to pm, pm#subtype is inverse of pm#supertype.
</pre></div><div class="FL"><pre>
FL:    pm#subtype  inverse: pm#supertype;  //'-' can be used instead of "inverse:"
</pre></div><div class="FCG"><pre>
FCG:   [pm#subtype, owl#inverse_of: pm#supertype](pm);
</pre></div><div class="KIF"><pre>
KIF:   (dc#Creator '(<=> (pm#subtype ?x ?y) (pm#supertype ?y ?x)) owl)
KOWLL: (dc#Creator '(owl#inverse_of pm#subtype pm#supertype) pm)
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;rdf:Property rdf:ID="&pm;subtype">
         &lt;owl:inverseOf rdf:resource="&pm;supertype" dc:Creator="pmartin@dstc.edu.au"/>
       &lt;/rdf:Property>
</pre></div><div class="N3"><pre>
N3:    pm:subtype a rdf:Property.
       {pm:subtype  owl:inverseOf pm:supertype} dc:Creator "pmartin@dstc.edu.au".
</pre></div><!--UML:   //image of an inverse association with creator-->

<p><br>OWL Lite also proposes the meta-classes <code>owl#symmetric_property</code>
and <code>owl#transitive_property</code>, <!-- <code>owl#functional_property</code>
and <code>owl#inverse_functional_property</code> --> to type classes of relations
that are symmetric or transitive. <!-- functional (i.e., with destination
cardinality 0..1) or inverse_functional (i.e., with source cardinality 0..1).
-->
However, only in OWL Full can these meta-classes be used to type classes of
relations that can have data types (integer, string, ...) as destinations.
The meta-classes <code>owl#symmetric_property</code> and
<code>owl#transitive_property</code> could be re-used in UML (see next example).














<p><br><br><a name="collections"></a><h2>9. Collections and Quantifier Precedence</h2>

<p>Collections have already been introduced in the previous section and via 
examples using numerical quantifiers. This section uses "AND collections"
and shows how various interpretations of the English sentence 
<i>"9 judges have approved 50 laws"</i> (and some variations of it)
can be interpreted.
This study of how relations between members of two simple collections can be
represented illustrates the importance of specifying how a collection must be
interpreted, and shows how to handle complex cases of quantifier precedence
(between numerical, existential and universal quantifiers).

<p>The sentence <i>"9 judges have approved 50 laws"</i> is ambiguous. 
The 9&nbsp;judges may have individually or collectively approved 50 laws
(the same 50 or not), and "collectively" may have two meanings: a 
participation to a "unique" approval act or the approval of "most" of
the laws (or a combination of both as ilustrated in the last example of
this section). This study shows that this leads to at least 32 different logical
interpretations.
In this document, "judges approving together/collectively" means that
"there exists a (unique) approval and each of the judges is agent of that 
approval". Similarly, "laws collectively approved" means that "there exists an
approval and each of the laws are object of that approval". This interpretation
of "collectiveness" was used in [<a href="#Sowa92">Sowa, 1992</a>] and,
in Conceptual Graph terminology, it implies that the approval must be represented
by a "concept node", not by a "relation node" (this result was however not
explicited by Sowa). In [<a href="#Sowa92">Sowa, 1992</a>],
any collection in a concept node of a conceptual graph can be specified as having
a <i>distributive interpretation</i> (each member of the collection individually 
participates to the relations associated to the node), 
a <i>collective interpretation</i> (the members collectively participate to the 
relations associated to the node), a <i>defaut interpretation</i> (an unspecified
mix of collective and distributive interpretation) or a <i>cumulative
interpretation</i> (the relations are about the collection itself).

<p>OWL (or more exactly RDF) introduces some notion of distributive interpretation
via the keyword <code>aboutEach</code> but it is not clear if this is the
default interpretation, the direct distributive interpretation or the general
distributive interpretation (the distinction between the last two will be explained
below). Without <code>aboutEach</code>, the relations are about the collection
itself (cumulative interpretation). However, in their examples, the RDF authors
also represent the collective interpretation via direct relations to the bag (e.g.,
see <a href="http://www.w3.org/TR/REC-rdf-syntax/#RepeatedProperties">Section&nbsp;3.5 of RDFMS</a>).
<!-- At least theoretically, OWL parsers may often repair this last ambiguity by
exploiting the signatures of the relations: if the expected type is not a 
collection, this is the collective interpretation, otherwise the ambiguity
remains. Hence, no new keyword, class or relation has been introduced for
specifying the collective interpretation in the following examples. However,-->
For the OWL translations, a relation type <code>interpretation</code>, a class
<code>set</code> and a relation type <code>size</code> have been introduced.
<!--since OWL does not propose such categories (however, see the note at the end
of the XOWLL translation). --> 
The type <code>set</code> is declared as a subtype of <code>rdf#bag</code>; this
permits the use of <code>rdf#about_each</code>.
<!--3) the specification of "collectiveness" relies on the use of
    a relation which has a bag as destination whereas it should not
    (although this is dubious, RDF does not seem to offer better options and
    the examples given by the authors of RDF currently lead to that solution).-->

<p>The first example keeps the ambiguity of the above cited
sentence (both collections have the default interpretation).
The `s' at the end of <code>judges</code> and <code>laws</code>
in the FE and FCG representations are supposed to be automatically removed
(WebKB-2 does this when a numerical or universal quantifier is involved).
In this section, FE and KRF translations are only given in this first example,
but a Predicate Logic (PL) translation is added using the symbols 
"&forall;"<!--A.--> for the universal quantifier, "&exist;"<!--E.--> for the existential quantifier, 
"&isin;" for membership to a set, and "^" for "and".
<div class="E"><pre>
E:     9 judges have (each/together) approved 50 laws.
</pre></div><div class="FE"><pre>
FE:    9 judges are agent of an approval with object 50 laws.
</pre></div><div class="FCG"><pre>
FCG:   [9 judges, agent of: (an approval, object: 50 laws)]
</pre></div><div class="KIF"><pre>
KIF:   (forAllN 9 '?j judge (forAllN 50 '?l law
         (exists ((?a approval)) (and (agent ?a '?j) (object ?a '?l)))))
PL:    &exist;js set(js)^size(js,9) ^ &forall;j&isin;js  &exist;ls set(ls)^size(ls,50) ^ &forall;l&isin;ls
         &exist;a approval(a) ^ agent(a,j) ^ object(a,l)
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;!-- 1st version -->
       &lt;rdf:Property rdf:ID="objectLaw">
         &lt;rdfs:subPropertyOf rdf:resource="#object"/>
         &lt;rdfs:range rdf:resource="#Law"/> &lt;/rdf:Property>
       &lt;owl:Class rdf:ID="ApprovalOf50laws">
         &lt;owl:intersectionOf rdf:parseType="Collection">
           &lt;Approval/>
           &lt;owl:Restriction>
             &lt;owl:cardinality rdf:datatype="&xsd;nonNegativeInteger">50
             &lt;/owl:cardinality>
             &lt;owl:onProperty rdf:resource="#objectLaw"/>&lt;/owl:Restriction>
         &lt;/owl:intersectionOf>&lt;/owl:Class>
       &lt;Set rdf:ID="Judges">&lt;size>9&lt;/size>&lt;/Set>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="separately">
         &lt;rdf:type rdf:resource="#Judge"/>&lt;/rdf:Description>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="default">
         &lt;agentOf>&lt;ApprovalOf50laws/>&lt;/agentOf>&lt;/rdf:Description>

  &lt;!-- The next version is shorter but highly tentative. It mostly relies on the
       special meaning of the relation "interpretation". RDF does not specify
       what embedded uses of aboutEach mean. More generally and mainly because
       it is based on triples, RDF has no clear notion of quantifier/statement
       scopes and insufficient means to specify them. -->
       &lt;Set rdf:ID="Laws"/>
       &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="separately">
          &lt;rdf:type rdf:resource="#Law"/>&lt;/rdf:Description>
       &lt;Set rdf:ID="Judges">&lt;size>9&lt;/size>&lt;/Set>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="separately">
          &lt;rdf:type rdf:resource="#Judge"/>&lt;/rdf:Description>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="default">
          &lt;agentOf>&lt;Approval>&lt;object> 
            &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="default">
              &lt;size>50&lt;/size> 
           &lt;/rdf:Description>&lt;/object>&lt;/Approval>&lt;/agentOf>&lt;/rdf:Description> -->
  &lt;!-- OWL may permit to define Judges as a set without introducing
          the class Set, in the following way:
            &lt;owl:AllDifferent>&lt;owl:distinctMembers>&lt;rdf:Bag rdf:ID="Judges"/>
                              &lt;/owl:distinctMembers>&lt;/owl:AllDifferent> -->
</pre></div><div class="N3"><pre>
N3:    :objectLaw a rdf:Property;  rdfs:subPropertyOf :object;  rdfs:range :Law.
       :ApprovalOf50laws a owl:Class; 
                         owl:intersectionOf :Approval,
                             [a owl:Restriction; owl:onProperty :objectLaw; owl:cardinality 50].
       :Judges a Set;  size 9.
       @forAll :j . { :j a :Judge;  is pm:member of :Judges } => { [a :ApprovalOf50laws] :agent :j }.
</pre></div><div class="KRF"><pre>
KRF:   QNode{cType:judge quantifier:Quantifier{num:"9"}
         sourceOf:isReversed Relation{rType:agent dest:
           QNode{cType:approval sourceOf: Relation{rType:object dest:
             QNode{cType:judge quantifier:Quantifier{num:"50"}}}}}}
</pre></div>
<p>Introduced constructs:
<pre>
&lt;rdf:Property rdf:ID="interpretation"/>
  &lt;rdfs:range rdf:resource="&rdfs;Literal"/>
&lt;/rdf:Property>

(defrelation forAllN (?num ?var ?type ?predicate) :=
  (exists ((?s set)) (and (size ?s ?num)
    (truth ^(forall (,?var) (=> (member ,?var ,?s)
                                (and (,?type ,?var) ,?predicate)))))))
//forAllN is nearly identical to the above defined atMostN: only the
//constraint on the size of the set differs
</pre>



<p><br><br>In FE and FCG, the order and scope of quantifiers is specified by
their order and the structure of the graphs.
The next example shows a simple inversion of the quantifier order.
<div class="E"><pre>
E:     50 laws have been approved by 9 judges (each/together).
</pre></div><div class="FCG"><pre>
FCG:   [50 laws, object of: (an approval, agent: 9 judges)]
</pre></div><div class="KIF"><pre>
KIF:   (forAllN 50 '?l law (forAllN 9 '?j judge
         (exists ((?a approval)) (and (agent ?a '?j) (object ?a '?l)))))
PL:    &exist;ls set(ls) ^ size(ls,50) ^ &forall;l&isin;ls  &exist;js set(js)^size(js,9) ^ &forall;j&isin;js
         &exist;a approval(a) ^ agent(a,j) ^ object(a,l)
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;!-- 1st version -->
       &lt;rdf:Property rdf:ID="agentJudge">
         &lt;rdfs:subPropertyOf rdf:resource="#agent"/>
         &lt;rdfs:range rdf:resource="#Judge"/> &lt;/rdf:Property>
       &lt;owl:Class rdf:ID="ApprovalBy9Judges">
         &lt;owl:intersectionOf rdf:parseType="Collection">
           &lt;Approval/>
           &lt;owl:Restriction>
             &lt;owl:cardinality rdf:datatype="&xsd;nonNegativeInteger">9
             &lt;/owl:cardinality>
             &lt;owl:onProperty rdf:resource="#agentJudge"/>&lt;/owl:Restriction>
         &lt;/owl:intersectionOf>&lt;/owl:Class>
       &lt;Set rdf:ID="Laws">&lt;size>50&lt;/size>&lt;/Set>
       &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="separately">
         &lt;rdf:type rdf:resource="#Law"/>&lt;/rdf:Description>
       &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="default">
         &lt;objectOf>&lt;ApprovalBy9Judges/>&lt;/objectOf>&lt;/rdf:Description>
</pre></div><div class="N3"><pre>
N3:    :agentJudge a rdf:Property;  rdfs:subPropertyOf :object;  rdfs:range :Judge.
       :ApprovalBy9Judges a owl:Class; 
                         owl:intersectionOf :Approval,
                             [a owl:Restriction; owl:onProperty :agentJudge; owl:cardinality 9].
       :Laws a Set;  size 50.
       @forAll :l . { :l a :Law;  is pm:member of :Laws } => {[a :ApprovalBy9judges] :object :l}.
</pre></div><!-- 2nd version (highly tentative):
       &lt;Set rdf:ID="Judges"/>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="separately">
          &lt;rdf:type rdf:resource="#Judge"/>&lt;/rdf:Description>
       &lt;Set rdf:ID="Laws">&lt;size>50&lt;/size>&lt;/Set>
       &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="separately">
          &lt;rdf:type rdf:resource="#Law"/>&lt;/rdf:Description>
       &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="default">
          &lt;objectOf>&lt;Approval>&lt;agent> 
            &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="default">
              &lt;size>9&lt;/size> 
            &lt;/rdf:Description>&lt;/agent>&lt;/Approval>&lt;/objectOf>&lt;/rdf:Description> -->


<p><br><br>In FE and FCG, the <i><b>collective interpretation</b></i> is specified
via the keywords <code>together, group of, set of, bag of, list of, sequence 
of</code> or <code>alternatives</code> (the first three are synonyms; in this
document, <code>set</code> is most often used).

<p>If we take the two previous examples and gradually introduce the collective 
interpretation for the collections (i.e., the sharing of the approvals
by the judges/laws, e.g., in the KIF translations, by gradually
moving "(exists ((?a approval)" to the left), we obtain five different logical 
interpretations (instead of six because when both collections are collectively 
interpreted, the inversion of quantifier order does not change the meaning).
Below are three of these combinations (the other two are: "A group of 50 laws
has been approved by 9 judges" and "A group of 9 judges has approved 50 laws").
<!--     ???@@@@@@@@@ before in FCG: a set of 50 laws; now:  50 laws together; RDF changed: no Laws set! -->
<!-- old versions for the first sentence: <div class="E"><pre>
E:     9 judges have (each/together) approved a group of 50 laws.
</pre></div><div class="FCG"><pre>
FCG:   [9 judges, agent of: (an approval, object: a set of 50 laws)]
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;Set rdf:ID="Laws"/>
       &lt;Set rdf:ID="Judges">&lt;size>9&lt;/size>&lt;/Set>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="default">
         &lt;rdf:type rdf:resource="#Judge"/>
         &lt;agentOf>&lt;Approval>&lt;object>
           &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="collective">
              &lt;size>50&lt;/size> &lt;rdf:type rdf:resource="#Law"/>
           &lt;/rdf:Description>&lt;/object>&lt;/Approval>&lt;/agentOf>&lt;/rdf:Description>
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;owl:Class rdf:ID="SetOfLaws">
         &lt;owl:intersectionOf rdf:parseType="Collection"> &lt;Set/>
           &lt;owl:Restriction>&lt;owl:onProperty rdf:resource="rdf:li"/>
             &lt;owl:allValuesFrom rdf:resource="#Law"/>&lt;/owl:Restriction>
         &lt;/owl:intersectionOf>&lt;/owl:Class>
       &lt;rdf:Property rdf:ID="objectNotBag">
         &lt;rdfs:subPropertyOf rdf:resource="#object"/>
         &lt;rdfs:range>&lt;owl:Class>&lt;owl:complementOf rdf:resource="rdf:Bag"/>
                     &lt;/owl:Class>&lt;/rdfs:range>&lt;/rdf:Property>
       &lt;Set rdf:ID="Judges">&lt;size>9&lt;/size>&lt;/Set>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="collective">
         &lt;rdf:type rdf:resource="#Judge"/>
         &lt;agentOf>&lt;Approval>
                    &lt;objectNotBag>&lt;SetOfLaws>&lt;size>50&lt;/size>&lt;/SetOfLaws>
                    &lt;/objectNotBag>&lt;/Approval>&lt;/agentOf>&lt;/rdf:Description>
       -- this is a highly tentative translation:
            1) it is unclear in RDF that not associating an ID to the SetOfLaws
               is a sufficient way to specify that there may be more than one
               set of laws (i.e., that the judge may not share the same set);
            2) such a use of rdf:li may not be understood by OWL engines;
            3) the relation "interpretation" has been introduced --
-->
<div class="E"><pre>
E:     9 judges have (each/together) approved a group of 50 laws.
</pre></div><div class="FCG"><pre>
FCG:   [9 judges, agent of: (an approval, object:  50 laws together)]
</pre></div><div class="KIF"><pre>
KIF:   (forAllN 9 '?j judge (exists ((?a approval) (?ls set))
         (forAllIn ?ls 50 '?l law (and (agent ?a '?j) (object ?a '?l)))))
PL:    &exist;js set(js)^size(js,9) ^ &forall;j &isin;js  &exist;a approval(a) ^
         &exist;ls set(ls)^size(ls,50) ^ &forall;l&isin;ls  agent(a,j) ^ object(a,l)
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;owl:Class rdf:ID="ApprovalOf50laws">
         &lt;owl:intersectionOf rdf:parseType="Collection" interpretation="collective">
           &lt;Approval/>
           &lt;owl:Restriction>
             &lt;owl:cardinality rdf:datatype="&xsd;nonNegativeInteger">50
             &lt;/owl:cardinality>
             &lt;owl:onProperty rdf:resource="#objectLaw"/>&lt;/owl:Restriction>
         &lt;/owl:intersectionOf>&lt;/owl:Class>
       &lt;Set rdf:ID="Judges">&lt;size>9&lt;/size>&lt;/Set>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="separately">
         &lt;rdf:type rdf:resource="#Judge"/>&lt;/rdf:Description>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="default">
         &lt;agentOf>&lt;ApprovalOf50laws/>&lt;/agentOf>&lt;/rdf:Description>
</pre></div><div class="N3"><pre>
N3:    :Judges a Set; size 9.
       @forAll :j.  { :j a :Judge; is pm:member of :Judges }
          => { @exist :a.  {:a a :approval.    :Laws at set; size 50}
                 => { @forAll :l.  { :l a :Law; is pm:member of :Laws}
                        => {:a :agent :j; :object :l}
                    } }
</pre></div>

<div class="E"><pre>
E:     50 laws have been approved by a group of 9 judges.
</pre></div><div class="FCG"><pre>
FCG:   [50 laws, object of: (an approval, agent: 9 judges together)]
</pre></div><div class="KIF"><pre>
KIF:   (forAllN 50 '?l law (exists ((?a approval) (?js set))
         (forAllIn ?js 9 '?j judge (and (agent ?a '?j) (object ?a '?l)))))
PL:    &exist;ls set(ls)^size(ls,50) ^ &forall;l &isin;ls  &exist;a approval(a) ^
         &exist;js set(js)^size(js,9) ^ &forall;j&isin;js  agent(a,j) ^ object(a,l)
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;Set rdf:ID="Judges"/>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="separately">
         &lt;rdf:type rdf:resource="#Judge"/>&lt;/rdf:Description>
       &lt;Set rdf:ID="Laws">&lt;size>50&lt;/size>&lt;/Set>
       &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="separately">
          &lt;rdf:type rdf:resource="#Law"/>&lt;/rdf:Description>
       &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="default">
         &lt;objectOf>&lt;Approval>&lt;agent>
           &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="collective">
              &lt;size>9&lt;/size>
           &lt;/rdf:Description>&lt;/agent>&lt;/Approval>&lt;/objectOf>&lt;/rdf:Description>
</pre></div><div class="N3"><pre>
N3:    :Laws a Set; size 50.
       @forAll :l.  { :l a :Law; is pm:member of :Laws }
          => { @exist :a.  @exist :Judges. {:a a :approval}
                 => { @forAll :j.  { :j a :Judge; is pm:member of :Judges.  :Judges a Set; size 9. }
                        => {:a :agent :j; :object :l}
                    } }
</pre></div>

<div class="E"><pre>
E:     A group of 9 judges has approved a group of 50 laws.
</pre></div><div class="FCG"><pre>
FCG:   [9 judges together, agent of:(an approval,object: 50 laws together)]
 or:   [a set of 50 laws, object of:(an approval,agent:a set of 9 judges)]
 or:   [an approval, agent: a set of 9 judges, object: a set of 50 laws]
</pre></div><div class="KIF"><pre>
KIF:   (exists ((?a approval) (?js set) (?ls set))
         (forAllIn ?js 9 '?j judge (forAllIn ?ls 50 '?l law
           (and (agent ?a '?j) (object ?a '?l)))))
PL:    &exist;a approval(a) ^ &exist;js set(js)^size(js,9) ^
         &exist;ls set(ls)^size(ls,50) ^  &forall;j&isin;js &forall;l&isin;ls agent(a,j) ^ object(a,l)
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;Set rdf:ID="Judges">&lt;size>9&lt;/size>&lt;/Set>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="separately">
         &lt;rdf:type rdf:resource="#Judge"/>&lt;/rdf:Description>
       &lt;Set rdf:ID="Laws">&lt;size>50&lt;/size>&lt;/Set>
       &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="separately">
          &lt;rdf:type rdf:resource="#Law"/>&lt;/rdf:Description>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="collective">
         &lt;agentOf>&lt;Approval>&lt;object>
           &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="collective"/>
                            &lt;/object>&lt;/Approval>&lt;/agentOf>&lt;/rdf:Description>
</pre></div><div class="N3"><pre>
N3:    :Judges a Set; size 9.  :Laws a Set; size 50.
       @exist :a. {:a a :approval}
         => { @forAll :j.  @forAll :l.  { :j a :Judge; is pm:member of :Judges}
              => {:a :agent :j; :object :l.   :l a :Law; is pm:member of :Laws}  }
</pre></div>

<p>Here is a definition for the "quantifier" <code>forAllIn</code>.<br>
<code>(defrelation forAllIn (?s ?num ?var ?type ?predicate) :=<br>
&nbsp; (and (size ?s ?num)<br>&nbsp;&nbsp;
&nbsp; &nbsp; (truth ^(forall (,?var) (=> (member ,?var ,?s)<br>&nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (and (,?type ,?var) ,?predicate))))))
</code>


<p><br><br>In [<a href="#Sowa92">Sowa, 1992</a>], the <i>distributive
interpretation</i> (i.e., where each member of the collection individually 
participates to the relations associated to the collection) specifies that each
member is connected to different objects, directly (i.e., via 1 relation) or
indirectly (i.e., 2 or more relations within the statement), unless otherwise
specified. For better precision, FE and FCG distinguishes the directly
distributive interpretation (which can be specified via the keyword "each") from
Sowa's general distributive interpretation (which can be specified via the
keyword "separately"). If the directly distributive interpretation is introduced
into the previous seven combinations, nine different logical interpretations are
obtained. A few more are obtained when the general distributive interpretation is
introduced; below are are two of them (in the KIF (resp. PL) translations,
replacing the first <code>exists1For</code> (resp. &exist;!!)  by <code>exists</code>
(resp. &exist;) leads to the direct distributive interpretation). 

<div class="E"><pre>
E:     9 judges have separately approved 50 laws (that's 450 approvals of law)
</pre></div><div class="FCG"><pre>
FCG:   [separately 9 judges, agent of: (an approval, object: 50 laws)]
</pre></div><div class="KIF"><pre>
KIF:   (forAllN 9 '?j judge (exists1For '?j '?ls set (forAllIn '?ls 50 '?l law
         (exists1For '?j '?a approval (and (agent '?a '?j) (object '?a '?l))))))
PL:    &exist;js set(js)^size(js,9) ^ &forall;j&isin;js   &exist;!!ls set(ls)^size(ls,50) ^
         &forall;l&isin;ls  &exist;!!a approval(a) ^ agent(a,j) ^ object(a,l)

</pre></div><div class="XOWL"><pre>
XOWLD: &lt;Set rdf:ID="Laws"/>
       &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="separately">
          &lt;rdf:type rdf:resource="#Law"/>&lt;/rdf:Description>
       &lt;Set rdf:ID="Judges">&lt;size>9&lt;/size>&lt;/Set>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="separately">
         &lt;rdf:type rdf:resource="#Judge"/>
         &lt;agentOf>&lt;Approval>&lt;object>
           &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="default">
              &lt;size>50&lt;/size>
           &lt;/rdf:Description>&lt;/object>&lt;/Approval>&lt;/agentOf>&lt;/rdf:Description>
</pre></div><div class="N3"><pre>
N3:    :Judges a Set; size 9.
       @forAll :j.  { :j a :Judge; is pm:member of :Judges }
           => { :Laws a Set; size 50.
                @forAll :l.  { :l a :Law; is pm:member of :Laws}
                  => { @exist :a. {:a a :approval} => {:a :agent :j; :object :l}
                       {:a :agent ?j; :object :l} => {?j = :j}
                       {:a :agent :j; :object ?l} => {?l = :l}
                     } }
</pre></div>

<div class="E"><pre>
E:    9 judges have separately approved a group of 50 laws (that's 450 approvals of law)
</pre></div><div class="FCG"><pre>
FCG:  [separately 9 judges, agent of: (an approval, object: a set of 50 laws)]
</pre></div><div class="KIF"><pre>
KIF:  (forAllN 9 '?j judge (exists1For '?j '?ls set (exists1For '?j '?a approval
        (forAllIn '?ls 50 '?l law (and (agent '?a '?j) (object '?a '?l))))))
PL:   &exist;js set(js)^size(js,9) ^ &forall;j&isin;js   &exist;!!ls set(ls)^size(ls,50) ^
        &exist;!!a approval(a)  &forall;l&isin;ls  agent(a,j)^ object(a,l)
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;Set rdf:ID="Laws"/>
       &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="separately">
          &lt;rdf:type rdf:resource="#Law"/>&lt;/rdf:Description>
       &lt;Set rdf:ID="Judges">&lt;size>9&lt;/size>&lt;/Set>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="separately">
         &lt;rdf:type rdf:resource="#Judge"/>
         &lt;agentOf>&lt;Approval>&lt;object>
           &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="collective">
              &lt;size>50&lt;/size>
           &lt;/rdf:Description>&lt;/object>&lt;/Approval>&lt;/agentOf>&lt;/rdf:Description>
</pre></div><div class="N3"><pre>
N3:    :Judges a Set; size 9.
       @forAll :j.  { :j a :Judge; is pm:member of :Judges }
           => { :Laws a Set; size 50.  @exist :a.
                @forAll :l.  { :l a :Law; is pm:member of :Laws}
                  => {  {:a a :approval; :agent :j; :object :l}
                        {:a :agent ?j; :object :l} => {?j = :j}
                        {:a :agent :j; :object ?l} => {?l = :l}
                     }
              } 
</pre></div>

<p>Below is a KIF definition of <code>exists1For</code>. This quantifier permits
us to specify that the judges are agent of different approvals of
different laws (first example) or groups of laws (second example).<br>
<code>(defrelation exists1For (?var1 ?var2 ?type ?predicate) :=<br>
&nbsp; (truth ^(exists (,?var2)<br>
&nbsp; &nbsp; (and (,?type ,?var2)&nbsp; (,?predicate ,?var1 ,?var2)<br>&nbsp;
&nbsp;
&nbsp; &nbsp;&nbsp; (forall (?x) (=> (,?predicate ,?var1 ?x) (= ,?var2 ?x)))<br>
&nbsp; &nbsp;&nbsp; 
&nbsp; &nbsp;  (forall (?y) (=> (,?predicate ?y ,?var2) (= ,?var1 ?y)))))))
</code>



<p><br><br>Finally, "most" can also be introduced as an interpretation of
collectiveness in each of the previous (7+9=16)&nbsp;combinations (hence,
16&nbsp;logical interpretations again). Here is one of them.
<div class="E"><pre>
E:     A group of 50 laws has been approved by most in a group of 9 judges.
</pre></div><div class="FCG"><pre>
FCG:   [a group of 9 judges, agent of:
         (an approval, object: most in a group of 50 laws)]
</pre></div><div class="FCG"><pre>
FCG:   [most in a group of 50 laws, object of:
         (an approval, agent: a group of 9 judges)]
</pre></div><div class="KIF"><pre>
KIF:   (exists ((?a approval) (?js set) (?ls set))
         (forAllIn ?js 9 '?j judge (forMostIn ?ls 50 '?l law
           (and (agent ?a '?j) (object ?a '?l)))))
PL:    &exist;a approval(a) ^  &exist;js set(js)^size(js,9) ^  &exist;ls set(ls)^size(ls,50) ^
         &forall;j&isin;js agent(a,j) ^  &exist;mostOfls set(mostOfls)
           (&forall;l&isin;ls  (object(a,l) => l&isin;mostOfls))   ^  size(mostOfls) >= 2
                                                 // >=2 since size(ls)/2=1.5 
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;Set rdf:ID="Judges"/>
       &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="separately">
         &lt;rdf:type rdf:resource="#Judge"/>&lt;/rdf:Description>
       &lt;Set rdf:ID="Laws">&lt;size>50&lt;/size>&lt;/Set>
       &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="separately">
          &lt;rdf:type rdf:resource="#Law"/>&lt;/rdf:Description>
       &lt;rdf:Description rdf:aboutEach="#Laws" interpretation="collective">
         &lt;objectOf>&lt;Approval>&lt;agent>
           &lt;rdf:Description rdf:aboutEach="#Judges" interpretation="collective"
                                                    quantifier="most">
              &lt;size>9&lt;/size>
           &lt;/rdf:Description>&lt;/agent>&lt;/Approval>&lt;/objectOf>&lt;/rdf:Description>
</pre></div><div class="N3"><pre>
N3:    @exist :a. {:a a :approval}  :Judges a Set; size 9.  :Laws a Set; size 50.
       @forAll :j.  { :j a :Judge; is pm:member of :Judges }
           => { {:a :agent :j;}.  @forSome :mostOfls. :mostOfls a :Set; >= 2.
                @forAll :l.  { :l a :Law; is pm:member of :Laws}
                  =>{ {:a :object :l} => {:l is pm:member of :mostOfls} }
              }
</pre></div>
<!-- PB: <size>9</size> invalid on a collective interpreted set @@@@@@@@@@@@@@@@@@@@@@@@@@ -->
<!-- ABOVE: @@@@ >=2 since size(ls)/2=1.5 @@@@  :mostOfls a :Set; >= 2.  @@@@@@@@ -->
<p>Here is a KIF definition of <code>forMostIn</code>
(the definition of <code>numMembersSuchThat</code> was given earlier).<br>
<code>(defrelation forMostIn (?set ?num ?var ?type ?predicate) :=<br>
&nbsp; (and (size ?set ?num)<br>&nbsp; &nbsp;&nbsp;
&nbsp;      (truth ^(forall (,?var) (=> (member ,?var ,?set) (,?type ,?var))))<br>
&nbsp; &nbsp;&nbsp;
&nbsp;      (>= (numMembersSuchThat ,?set ,?predicate) (* (size ,?set) 0.6))))</code>
<!-- <pre>(defrelation forMostIn (?set ?num ?var ?type ?predicate) :=
  (and (size ?set ?num)
       (truth ^(forall (,?var) (=> (member ,?var ,?set) (,?type ,?var))))
       (>= (numMembersSuchThat ,?set ,?predicate) (* (size ,?set) 0.6))))
</pre> -->









<p><br><br><a name="higherOrder"></a><h2>10. Higher-order Statements</h2>

<p>First-order statements only permit to use universal quantification
over individuals. Higher-order statements also permit to universal quantification
over types. OWL does not permit genuine universal quantification (it only
accepts certain forms of class definition) or rules.
The definition of <code>transitive_binary_relation</code> requires such features
and is a classic example of second-order statement. (A first-order statement is
sufficient to describe the transitivity of a particular relation, e.g.,
"the part of a part is also a part", but would also be difficult to express in
OWL without using the type <code>owl#transitive_property</code>.
Hence, as opposed to the previous examples, a "slight" extension to OWL would be
insufficient for the example below. Instead, the proposed translation uses 
<a href="http://www.w3.org/DesignIssues/Toolbox.html">"big" extensions to RDF</a>
imagined by Berners-Lee in 1999: a <code>forall</code> construct and new
attributes such as <code>pname</code> to quantify over classes. However, in 2001, 
DAML+OIL, the precursor of the OWL, was adopted by the W3C as an extension to RDF,
and hence it is unlikely that Tim Berners Lee's extensions for genuine universal
quantification will be adopted in the future.
<div class="E"><pre>
E:    A transitive_binary_relation_type rt is such that
        if x is connected to y by a relation of type rt, and 
           y is connected to z by a relation of type rt, 
        then x is connected to z by a relation of type rt.
</pre></div><div class="FCG"><pre>
FCG:  [type transitive_binary_relation_type (*rt) :=
        [ [^x, *rt: (^y, *rt: ^z)] => [^x, *rt: ^z]
        ]] //^x and ^y are "free variables", i.e., variables that are
           //implicitely universally quantified (KIF also accepts them)
</pre></div><div class="KIF"><pre>
KIF:  (defrelation transitive_binary_relation_type (?rt) :=
        (and (binrel ?rt ?s)     //?s is a free variable
             (forall (?x ?y ?z)
               (=> (and (?rt ?x ?y) (?rt ?y ?z)) (?rt ?x ?z)))))
      //to be accepted in all the versions of KIF, it would be better to write 
      //    (=> (and (holds ?rt ?x ?y)(holds ?rt ?y ?z))(holds ?rt ?x ?z)))))
      //but since variables for predicates have already been used in definitions
      //above, that facility is re-used here
</pre></div><div class="XOWL"><pre>
RDF+: &lt;forall var="r" v2="x" v3="y" v4="z"> &lt;!--var,v2,v3,v4: new attributes-->
        &lt;if>&lt;TransitiveBinaryRelationType rdf:about="#rt">
        &lt;then>&lt;if>&lt;rdf:Description about="#x">
                    &lt;rdf:property pname="#rt">&lt;!-- pname: new attribute -->
                      &lt;rdf:Description about="#y">
                        &lt;rdf:property pname="#rt">&lt;rdf:Description about="#z"/>
                        &lt;/rdf:property>&lt;/rdf:Description>
                    &lt;/rdf:property>&lt;/rdf:Description>
              &lt;then>&lt;rdf:Description about="#x">
                      &lt;rdf:property pname="#rt">&lt;rdf:Description about="#z"/>
                      &lt;/rdf:property>&lt;/rdf:Description>
              &lt;/then>&lt;/if>&lt;/then>&lt;/if>&lt;/forall>
</pre></div><div class="N3"><pre>
N3:   @forAll :rt .{ :rt a owl:TransitiveProperty. } log:implies
      { @forAll :x , :y , :z.
        { :x :rt :y. :y :rt :z. } log:implies { :x :rt :z. }.
      }.  &lt;!-- assuming that :rt is a variable for a type, not a type -->
</pre></div><div class="KRF"><pre>
KRF:   Definition {dType:MetaType transitive_binary_relation_type
                   kind:NSC  parameter:("rt") embeddedNode1:ENode {
         embeddedNode1:
           QNode {var:"x" sourceOf:Relation{var:"rt" dest:
             QNode{var:"y" sourceOf:Relation{var:"rt" dest:QNode{var:"z"}}}}}
         sourceOf: ENode {embeddedNode1:
           QNode {var:"x" sourceOf:Relation{var:"rt" dest:QNode{var:"z"}}}}}}
</pre></div>
<!--   &lt;rdf:Property rdf:ID="instance">
         &lt;owl:inverseOf rdf:resource="&rdf;type"/>&lt;/rdf:Property>
       &lt;owl:Class rdf:ID="TransitiveBinaryRelationType">
         &lt;owl:equivalentClass>&lt;owl:Restriction>
           &lt;owl:onProperty rdf:resource="#instance"/>
           &lt;owl:allValuesFrom>&lt;owl:Class rdf:ID="rt">
             &lt;owl:equivalentClass>&lt;owl:Restriction>
               &lt;owl:onProperty rdf:resource="#instance"/>
               &lt;owl:allValuesFrom>???&lt;/owl:allValuesFrom>
             &lt;/owl:Restriction>&lt;/owl:equivalentClass>
           &lt;/owl:Class>&lt;/owl:allValuesFrom>
         &lt;/owl:Restriction>&lt;/owl:equivalentClass>&lt;/owl:Class>
-->




<p><br><br><a name="measuresAndIntervals"></a><h2>11. Ontology-dependent Representations</h2>
<!-- see also the 93% bird example above -->
<p><a name="measures"></a><h3>Measures</h3>
<p>Although measure representation is a "content ontology" issue (such as how to
represent relations from states, processes or statements) rather than a
"language ontology" issue (such as quantification and contextualization), it
has to be treated now because FE and FCG provide shortcuts which are discussed
after this example.
<div class="E"><pre>
E:     There is a car that weights 923.5 kg.
</pre></div><div class="FE"><pre>
FE:    There is a car that has for weight 923.5 kg.
</pre></div><div class="FCG"><pre>
FCG:   [a car, weight: 923.5 kg]
 or:   [a car, weight: a weight *w] [measure(*w,923.5,kg)]
</pre></div><div class="KIF"><pre>
KIF:   (exists ((?c car) (?w weight))
         (and (weight2 ?c ?w) (measure ?w 923.5 kg)))
</pre></div><div class="XOWL"><pre>
XOWLL: &lt;Car>&lt;weight>&lt;Weight>&lt;measure>&lt;Measure>&lt;unit rdf:resource="#kg"/>
                                              &lt;number>923.5&lt;/number>&lt;/Measure>
                            &lt;/measure>&lt;/Weight>&lt;/weight>&lt;/Car>
</pre></div><div class="N3"><pre>
N3:    [a :Car; :weight2 [a :Weight; :measure; [a :Measure; :unit :kg; :number "923.5"] ] ].
</pre></div><div class="KRF"><pre>
KRF:   QNode{cType:car  sourceOf:Relation{rType:weight dest:
         QNode{cType:kg quantifier:Quantifier{num:"923.5"}}}}
</pre></div>

<p>As illustrated above, in FE and FCG, instead of using the relation
<code>measure</code>, a real number can be put in front of a "unit" class as if it
was  a collection-related numerical quantifier (a difference is that this numerical
quantifier can only be a positive integer since it represents the number of objects
in a collection). FE and FCG also permit a "dimension" class (or more generally any
subclass of <code>pm#thing_that_can_be_seen_as_a_relation</code>) to be used
as if it was a relation type (which implicitely has for range an object of
the class). This eases the entering, reading and matching of statements,
and avoids duplicating the hierarchy of classes for dimensions into a
hierarchy of relation types for these dimensions (as must be done with the
other notations). This approach is also consistent with the way qualitative
values are represented (e.g., a certain <code>red</code> represents 
a certain number of hertz, and a red car can be represented as 
<code>[a car,&nbsp;color:&nbsp;a&nbsp;red]</code>). However, this approach
implies that <code>red</code> is a subclass of <code>color</code> and
<code>kg</code> is a subclass of <code>weight</code>. This is a rather natural
categorization and is the case in WordNet, but some ontologies (e.g., DOLCE)
categorize <code>red</code> and <code>kg</code> as <i>dimension values</i> (or
"quales") which are exclusive with <i>dimensions/attributes</i> (or "qualities").
Since this alternative approach does not permit to exploit
generalization links, it either requires the introduction of relations and
definitions to connect each dimension and its related values, or inferencing
possibilities are lost, and hence this not a scalable approach.
However, if this is done, such ontologies can be used with the above approach.
For example, assuming that <code>red</code> now denotes a dimension value, and
that <code>value</code> is a generic relation between dimensions and dimension
values, the following FCG can be written: 
<code>[a car,&nbsp;color:&nbsp;(a color,&nbsp;value:&nbsp;a&nbsp;red)].</code>



<p><br><br><a name="intervals"></a><h3>Intervals</h3>
<p>An interval of numerical quantifiers has different representations depending
on their meaning: number of objects or measure. Below is an example.
Alternatively, if the interval is simply a collection of 2 numbers, the usual 
representation for a collection is sufficient.
<div class="E"><pre>
E:     2 to 3 persons are running for 45.5 minutes to an hour.
</pre></div><div class="FE"><pre>
FE:    2 to 3 persons is agent of a run with duration 45.5 to 60 minutes.
</pre></div><div class="FCG"><pre>
FCG:   [2 to 3 persons, agent of: (a run, duration: 45 to 60 minute)]
</pre></div><div class="KIF"><pre>
KIF:   (forAllInBetween 2 3 '?p person
         (exists ((?r run) (?d duration) (?n number))
           (and (duration2 ?r ?d) (measure ?d ?n minute)
                (>= ?n 45.5) (=< ?n60))))
</pre></div><div class="XOWL"><pre>
XOWLD: &lt;Set rdf:ID="persons"/>
       &lt;Set rdf:ID="Persons">&lt;size>&lt;Number>&lt;atLeast>2&lt;/atLeast>
                                     &lt;atMost>3&lt;/atMost>&lt;Number>&lt;/size>&lt;/Set>
       &lt;rdf:Description rdf:aboutEach="#Persons" interpretation="default">
         &lt;rdf:type rdf:resource="#Person"/>
         &lt;agentof>&lt;Run>&lt;duration>&lt;Duration>&lt;measure>
                                   &lt;Measure>&lt;unit rdf:resource="#minutes"/>
                                            &lt;number>45.5&lt;/number>&lt;/Measure>
                                   &lt;/Measure>&lt;/measure>&lt;/duration>&lt;/Duration>
                  &lt;/Run>&lt;/agentof>&lt;/rdf:Description>
</pre></div><div class="N3"><pre>
N3:    :Persons a Set; :size [a :Number; atLeast 2; atMost 3].
       @forAll :p. {:p a :Person; is :member of :Persons}
          => { [a :Run;  agent :p;  :duration
                  [a Duration; measure
                    [a :Measure; :unit :minute; :atLeast "45.5"; :atMost "60"]
                  ] ] }
</pre></div><div class="KRF"><pre>
KRF:   QNode{cType:person quantifier:Quantifier{num:"2" toNumber:"3"}
         sourceOf:isReversed Relation{rType:agent dest:
           QNode{cType:run sourceOf:Relation{rType:duration dest: QNode{
             cType:"minute" quantifier:Quantifier{num:"45.5" toNumber:"60"}}}}}}

</pre></div>

<p>Here is a KIF definition of <code>forAllInBetween</code>.<br>
<code>(defrelation forAllInBetween (?s ?n1 ?n2 ?var ?type ?predicate) :=<br>
&nbsp; (exists (?n) (and (size ?s ?n) (>= ?n ?n1) (=< ?n ?n2)<br>&nbsp;&nbsp;
&nbsp; &nbsp; (truth ^(forall (,?var) (=> (member ,?var ,?s)<br>&nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (and (,?type ,?var) ,?predicate))))))
</code>



<p><br><br><a name="qualitative"></a><h3>Qualitative Valuations</h3>
















<!--
<p><br><br><i>What is written below comes from 
<a href="translations.html">another document</a>. This content has to be 
adapted to OWL and refined for the purpose of the ODM RFP.</i><br>


<p><br><br><a name="versions"></a><h2>Relation Between Ontology Versions</h2>

<p> owl#deprecated_class owl#deprecated_property 
 pm#relation_between_OWL_ontologies (owl#ontology,owl#ontology)
       > owl#backward_compatible_with owl#incompatible_with owl#prior_version ;

<p><br><br><a name="conclusion"></a><h2>Conclusion</h2>

<p>
-->



<p><br><br><a name="bibliography"></a><h2>Bibliography</h2>

<p><a href="../papers/iccs01/">Martin Ph. & Eklund P. (2001)</a>.
<i>Large-scale cooperatively-built heterogeneous KBs.</i>
Proceedings of <a href="http://www.ksl.Stanford.EDU/iccs2001/">ICCS'01</a>,
9th International Conference on Conceptual Structures
(Springer Verlag, LNAI 2120, pp.&nbsp;231-244), Stanford University, California,
USA, July&nbsp;30&nbsp;to&nbsp;August&nbsp;3,&nbsp;2001.
<small>http://www.webkb.org/doc/papers/iccs01/</small>

<p><a href="../papers/iccs02/">Martin Ph. (2002a)</a>.
<i>Knowledge representation in CGLF, CGIF, KIF, Frame-CG and Formalized-English.</i>
Proceedings of <a href="http://www.lml.bas.bg/iccs2002/">ICCS'02</a>,
10th International Conference on Conceptual Structures
(Springer Verlag, LNAI 2393, pp.&nbsp;77-91),
Borovets, Bulgaria, July&nbsp;15-19,&nbsp;2002.
<small>http://www.webkb.org/doc/papers/iccs02/</small>

<p>M. Chein and M.L. Mugnier, Positive Nested Conceptual Graphs,
   Proceedings of ICCS'97, 5th International Conference on
   Conceptual Structures (Springer Verlag, LNAI 1257, pp.&nbsp;95-109),
   Seattle, USA, August&nbsp;4-8, 1997.

<p><a name="Sowa92" href="http://users.bestweb.net/~sowa/">J.F. Sowa</a> (1992).
   <i>Conceptual Graphs Summary.</i>
   In: Conceptual Structures: Current Research and Practice
   (Eds: T.E. Nagle, J.A. Nagle, L.L. Gerholz and P.W. Eklund),
   Ellis Horwood (1992), pp. 3-51.

<!--
<p><a name="Sowa93" href="http://users.bestweb.net/~sowa/">J.F. Sowa</a> (1993).
   <i>Relating Diagrams to Logic.</i>
   In Proc. of ICCS'93 (Eds: G.W. Mineau, B. Moulin and J.F. Sowa),
   LNAI 699, pp. 1-35.
-->
</body>
</html>
